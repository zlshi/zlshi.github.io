<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown语法说明]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Markdown语法 &copy; ##特殊字符自动转换在HTML中&lt; 和&amp;会转换为&amp;lt;和&amp;amp; ##区块元素 ###段落和换行一个MarkDown段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本组成」这句话其实暗示了Markdown允许段落内强迫换行（插入换行符），这个特性和其他大部分的text-to-HTML格式不一样（包括Movable Type的「Convert Line Breaks」选项），其他的格式会把每个换行符都转换成&lt;br/&gt;标签。 ###标题Markdown支持两种标题语法，类Setext和类atx形式。类Setext形式是用底线的形式，利用=（最高阶标题）和-（第二阶标题），例如：12345This is an H1==========This is an H2---------------- 任何数量的=和-都可以有效果。效果： This is an H1This is an H2类Atx形式则是在行首插入1到6个#，对应标题1到6阶，例如：123# 这是H1## 这是H2###### 这是H6 效果： 这是H1这是H2这是H6你可以选择性地「闭合」类atx样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你可以在行尾加上#，而行尾的#的数量也不用和开头一样（行首的#字符数量决定标题的阶数）：12# 这是H1 ### 这是H2 ## ###区块引用 BlockquotesMarkdown标记区块引用是使用类似email中用&gt;的引用方式。如果你还熟悉在email信件中的引言部分，你就知道怎么在Markdown文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;：123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 效果： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown也允许你偷懒只在整个段落的第一行加上&gt;：123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 效果： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;：12345&gt; This is first level of quoting.&gt;&gt;&gt; This is nested blockquote.&gt;&gt; Back to the first level. 效果： This is the first level of quoting. This is nested blockquote. Back to the first level. 引用区块内也可以使用其他Markdown语法，包括标题、列表、代码区块等：12345678&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 效果： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $inout | $markdown_script”); 列表Markdown支持有序列表和无序列表无序列表使用星号、加号或是减号作为列表标记：123* Red* Green* Blue 效果： Red Green Blue 等同于：123+ Red+ Green+ Blue 效果: Red Green Blue 也等同于：123- Red- Green- Blue 效果： Red Green Blue 有序序号则使用数字接着一个英文句点：1231. Bird2. McHale3. Parish 效果： Bird McHale Parish 很重要的一点是，你在列表上使用的数字并不会影响输出的HTML结果，上面的列表所产生的HTML标记为：12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的列表标记写成：1231. Bird1. McHale1. Parish 或者是：1233. Bird1. McHale8. Parish 你都会得到完全相同的HTML输出。重点在于，你可以让Markdown文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从1.开始，因为Markdown未来可能会支持有序列表的start属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，做多3个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 效果： Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果项目列表间用空行分开，在输出HTML时Markdown就会将项目内容用&lt;p&gt;标签包起来，举例来说：12* Bird* Magic 会被转换为：1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个：123* Bird* Magic 会被转换为:1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符：123456781. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 效果： This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会好看很多，当然，再次地，如果你很懒惰，Mardown也允许：1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 效果： This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. 如果要在列表项目内放进引用，那&gt;就需要缩进：1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 效果： A list item with a blockquote: This is a blockquoteinside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是8个空格或是2个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 效果： 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生像下面这样的写法：11986. What a great season. 效果： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。11986\. What a great season. 效果： 1986. What a great season. ###代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown会用&lt;pre&gt;和&lt;code&gt;标签来把代码区块包起来。要在Markdown中建立代码区块很简单，只要简单地缩进4个空格或是一个制表符就可以，例如：123这是一个普通段落： 这是一个代码区块。 Markdown会转换成：1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 效果： 这是一个普通段落： 这是一个代码区块。这是一个普通段落： 这是一个代码区 这个每行一阶的缩进（4个空格或是1个制表符），都会被移除，例如：12345Here is an example of AppleScript: tell application "Foo" beep end tell 会被转换为：123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application "Foo" beepend tell&lt;/code&gt;&lt;/pre&gt; 效果： Here is an example of AppleScript: tell application “Foo” beepend tell一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面，&amp;、&lt;、和&gt;会自动转成HTML实体，这样的方式让你非常容易使用Markdown插入范例用的HTML原始码，之需要复制粘帖上，再加上缩进就可以了，剩下的Markdown都会帮你处理，例如：123&lt;div class="footer"&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为：1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 效果： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 代码区块中，一般的Markdown语法不会被转换，像是星号便只是星号，这表示你可以很容易地以Markdown语法撰写Markdown语法相关的文件。 ###分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：123456* * *********---- - -_____________ 效果： ##区段元素 ###链接Markdown支持两种形式的链接语法：行内式和参考式两种形式。不管是哪一种，链接文字都是用[方括号]来标记。 要建立一个行内式的链接，只要在方括号后面紧接着圆括号并插入网址链接即可，如果你还想加上链接的title文字，只要在网址后面，用双引号把title文字包起来即可，例如：123This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. 会产生：12345&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 效果：This is an example inline link. This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径：1See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而第二个方括号里面要填入用以辨识链接的标记：1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格：1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：1[id]: http://example.com/ "Optional Title Here" 效果： This is an example reference-style link. This is an example reference-style link.链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的地址 选择性地接着title内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同：123[foo1]: http://example.com/ "Optional Title Here"[foo2]: http://example.com/ 'Optional Title Here'[foo3]: http://example.com/ (Optional Title Here) 效果： This is foo of first[foo2]: http://example.com/ ‘Optional Title Here’This is [foo of second][foo2] This is foo of third链接的网址也可以用尖括号包起来：1[id]: &lt;http：//example.com/&gt; "Optional Title Here" 你也可以把title属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：12[id]: http://example.com/longish/path/to/resource/here "Optional Title Here" 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：12[link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让“Google”链接到google.com,你可以简化成:1[Google][] 然后定义链接内容：1[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：1Visit [Daring Fireball][] for more information. 然后接着定义链接：1[Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。下面是一个参考式链接的范例：123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ "Google" [2]: http://search.yahoo.com/ "Yahoo Search" [3]: http://search.msn.com/ "MSN Search" 如果改成用链接名称的方式写：123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ "Google" [yahoo]: http://search.yahoo.com/ "Yahoo Search" [msn]: http://search.msn.com/ "MSN Search" 上面两种写法都会产生下面的 HTML。1234&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"title="Google"&gt;Google&lt;/a&gt; than from&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：123I get 10 times more traffic from [Google](http://google.com/ "Google")than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or[MSN](http://search.msn.com/ "MSN Search"). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 ###强调Markdown使用(*)和(_)作为标记强调字词的符号，被*或_包围的字词会被转成用&lt;em&gt;标签包围，用两个*或_包起来的话，则会被转成&lt;strong&gt;，例如：1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成：1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 效果： single asterisks single underscores double asterisks double underscores 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间：1un*frigging*believable unfriggingbelievable但是如果你的*和_两边都有空白的话，它们只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：1\*this text is surrounded by literal asterisks\* *this text is surrounded by literal asterisks* ###代码如果要标记一小段行内代码，你可以用反引号把它包起来（`)，例如：1Use the `printf()` function. 会产生：1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 效果：Use the printf() function.如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：1``There is a literal backtick (`) here.`` 这段语法会产生：1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 效果： There is a literal backtick (`) here. 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 会产生：123&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 效果： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：1Please don't use any `&lt;blink&gt;` tags. 转为：1&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 效果： Please don’t use any &lt;blink&gt; tags. 你也可以这样写：1`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生：12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 效果： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. ###图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是：123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") 详细叙述如下： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’文字。 参考式的图片语法则长得像这样：1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：1[id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt;标签。 ##其它 ###自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：1&lt;http://example.com/&gt; Markdown 会转为：1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 效果： http://www.baidu.com/ 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：1&lt;address@example.com&gt; Markdown 会转成：1234&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 效果：&#97;&#100;&#x64;&#114;&#x65;&#115;&#115;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） ###反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠：1\*literal asterisks\* 效果： *literal asterisks* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 ##注释stackoverflow markdown注释单行12[//]: # "Comment"[//]: # (Comment)]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vagrant介绍与使用]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2Fvagrant-e4-bb-8b-e7-bb-8d-e4-b8-8e-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Vagrant是自动配置虚拟机的软件，定义好Vagrantfile配置文件 即可通过vagrant up启动一批虚拟机环境。在多人协作开发时可以通过配置来保证每个开发人员构建的机器环境一致参考官网vagrant]]></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux屏幕截图]]></title>
    <url>%2Fblog%2F2017%2F07%2F11%2Flinux-e5-b1-8f-e5-b9-95-e6-88-aa-e5-9b-be%2F</url>
    <content type="text"><![CDATA[使用命令截图 安装scrot后 scrot -s filename.png 鼠标选择窗口]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FFT理解实现及应用]]></title>
    <url>%2Fblog%2F2016%2F05%2F08%2Ffft-e7-90-86-e8-a7-a3-e5-ae-9e-e7-8e-b0-e5-8f-8a-e5-ba-94-e7-94-a8%2F</url>
    <content type="text"><![CDATA[FFT的理解参考算法导论与FFT的简单理解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLYWEIGHT(享元)---对象结构型模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fflyweight-e4-ba-ab-e5-85-83-e5-af-b9-e8-b1-a1-e7-bb-93-e6-9e-84-e5-9e-8b-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>FLYWEIGHT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中克隆与拷贝构造函数]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fjava-e4-b8-ad-e5-85-8b-e9-9a-86-e4-b8-8e-e6-8b-b7-e8-b4-9d-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[参考A Guide to Object Cloning in JavaWhich is better option: Cloning or Copy constructors? Cloning 含义当我们使用clone()方法时，JVM做如下两件事：1. 如果这个类只包含原始数据类型成员，则创建一个对象的拷贝，原始数据成员被依次拷贝，返回指向新对象的Reference2. 如果类还包括引用数据类型则只拷贝了它的引用，没有开辟新的空间。 Java中的Clonejava中的类要支持clone需要实现如下两条1. 实现Cloneable接口2. 重写clone()方法Java docs about clone() method are given below (formatted and extract). /* Creates and returns a copy of this object. The precise meaning of "copy" may depend on the class of the object. The general intent is that, for any object x, the expression: 1) x.clone() != x will be true 2) x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements. 3) x.clone().equals(x) will be true, this is not an absolute requirement. */ protected native Object [More ...] clone() throws CloneNotSupportedException; 第一条保证克隆对象和原对象在内存的不同地方（内存地址不一样） 第二条建议克隆对象和原始对象有相同的类类型，但不强制 第三条建议克隆对象和原始对象使用equals比较是形同，但也不强制 例子： string也会被拷贝是因为String类是不可变的,对String类的任何改变,都是返回一个新的String类对象Our first class is Employee class with 3 attributes. Id, name and department. public class Employee implements Cloneable{ private int employeeId; private String employeeName; private Department department; public Employee(int employeeId, String employeeName, Department department) { this.employeeId = employeeId; this.employeeName = employeeName; this.department = department; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } public int getEmployeeId() { return employeeId; } public void setEmployeeId(int employeeId) { this.employeeId = employeeId; } public String getEmployeeName() { return employeeName; } public void setEmployeeName(String employeeName) { this.employeeName = employeeName; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } } class Department { private int id; private String name; public Department(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 测试类 public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); System.out.println(cloned.getEmployeeId()); System.out.println(original != cloned); System.out.println(original.getClass()== cloned.getClass()); System.out.println(original.equals(cloned)); } } 把String改为StringBuilder就不能实现拷贝 现在我们修改Department会发现 original数据也会被修改 public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); cloned.getDepartment().setName("Software Development"); System.out.println(original.getDepartment().getName()); } } Cloned object changes are visible in original also. This way cloned objects can make havoc in system if allowed to do so. Anybody can come and clone your application objects and do whatever he likes. 浅拷贝是Java中默认实现方式，上面例子实现的就是浅拷贝，因为我们在Employee类的克隆方法中没有克隆 Department. 深拷贝使在克隆对象上的改变不影响original 修改Employee的克隆方法 @Override public Object clone() throws CloneNotSupportedException { Employee cloned = (Employee)super.clone(); cloned.setDepartment((Department)cloned.getDepartment().clone()); return cloned; } 同时Department也要实现clone()方法 @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } 测试： public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); cloned.getDepartment().setName("Software Development"); System.out.println(original.getDepartment().getName()); System.out.println(cloned.getDepartment().getName()); } } 这时改变cloned的状态 不改变original的状态 实现深拷贝需要满足如下规则1. No need to separately copy primitives.2. All the member classes in original class should support cloning and in clone method of original class in context should call super.clone() on all member classes.3. If any member class does not support cloning then in clone method, one must create a new instance of that member class and copy all its attributes one by one to new member class object. This new member class object will be set in cloned object. 使用拷贝构造函数 public class PointOne { private Integer x; private Integer y; public PointOne (PointOne point) { this.x = point.x; this.y = point.y; } } 通过拷贝构造函数可以得到状态一致的对象 详见参考链接一 通过序列化克隆只要对应的类是可序列化的可以通过序列化机制实现克隆，做法： 直接将对象序列化到输出流中，然后将其读回。这样产生的新对象是对现有对象的一个深拷贝。可用ByteArrayOutputStream将数据保存到字节数组中。 但是 它通常会比显示地构建新对象并复制或克隆数据域的克隆方法慢的多，并且并不是所有对象是可序列化的，最后使类可序列化是很困难的，并不是所有的类都可以指望得到它的权利。 class Employee extends SerialCloneable { private String name; private double salary; private Date hireDay; public Employee(String n,double s,int year,int month,int day) { name = n; salary = s; GregorianCalendar calendar = new GregorianCalendar(year,month-1,day); hireDay = calendar.getTime(); } public String getName() { return name; } public double getSalary() { return salary; } public Date getHireDay() { return hireDay; } public void raiseSalay(double byPercent) { double raise = salary*byPercent/100.0; salary += raise; } public String toString() { return getClass().getName()+ "[name="+name +",salary="+salary +",hireDay="+hireDay +"]"; } } class SerialCloneable implements Cloneable,Serializable { @Override public Object clone() { try{ //save the object to a byte array ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bout); out.writeObject(this); out.close(); //read a clone of the object from the byte array ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream in = new ObjectInputStream(bin); Object ret = in.readObject(); in.close(); return ret; }catch(Exception e) { e.printStackTrace(); return null; } } } public class SerialCloneTest { public static void main(String[] args) { Employee harry = new Employee("Harry Hacker",35000,1989,10,1); Employee harry2 = (Employee)harry.clone(); harry2.raiseSalay(10); System.out.println(harry); System.out.println(harry2); } } 使用Apache工具包(using Apache commons)Apache commons has also utility function for deep cloning. If you feel interested the follow their official docs. Below is sample usage of cloning facility using Apache commons: SomeObject cloned = org.apache.commons.lang.SerializationUtils.clone(someObject); Best practices When you don’t know whether you can call the clone() method of a particular class as you are not sure if it is implemented in that class, you can check with checking if the class is instance of “Cloneable” interface as below. if(obj1 instanceof Cloneable){ obj2 = obj1.clone(); } //Dont do this. Cloneabe dont have any methods obj2 = (Cloneable)obj1.clone(); No constructor is called on the object being cloned. As a result, it is your responsibility, to make sure all the members have been properly set. Also, if you are keeping track of number of objects in system by counting the invocation of constructors, you got a new additional place to increment the counter.]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Clone</tag>
        <tag>Copy constructors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prototype Pattern(原型模式)]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fprototype-pattern-e5-8e-9f-e5-9e-8b-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[参考Prototype Design PatternFactory模式与Prototype模式的异同 the prototype is the object containing clone method used to clone similar objects to it for reducing the number of classesa solution to these problemsHow does one reduce the number of classes that share similar behavoir and relationships SolutionDefine a class to replace all the classes that share similar behavior and relationships. Save instances,called prototypes,of this class. To create an instance of any of the classes replaced, simply clone the desired prototype and modify its attributes Liabilities(缺点) The subclasses of prototype must implement the clone() method. This requires deep-copying if the instances and original must be independent;otherwise, shallow-copying is sufficient Implementing clone() may be difficult or impossible if the class is final or there are circular references 循环引用 无法克隆 Example Prototype in Java Create a “contract” with clone() and getName() entries Design a “registry” that maintains a cache of prototypical objects Populate the registry with an initializePrototypes() function The registry has a findAndClone() “virtual constructor” that can transform a String into its correct object (it calls clone() which then calls “new”) All classes relate themselves to the clone() contract Client uses the findAndClone() virtual ctor instead of the “new” operator package Prototype; interface Prototype { Object clone(); String getName(); } //1.The clone() contract interface Command { void execute(); } class PrototypesModule { //2\. &quot;registry&quot; of prototypical objs private static Prototype[] prototypes = new Prototype[9]; private static int total = 0; // Adds a feature to the Prototype attribute of the PrototypesModule class //obj The feature to be added to the Prototype attribute public static void addPrototype(Prototype obj) { prototypes[total++] = obj; } public static Object findAndClone(String name) { //4\. The &quot;virtual ctor&quot; for(int i=0;i&amp;lt;total;i++) { if(prototypes[i].getName().equals(name)) return prototypes[i].clone(); } System.out.println(name + &quot;not found&quot;); return null; } } //5\. Sign-up for the clone() contract `&lt;/pre&gt; &lt;/pre&gt; &lt;pre&gt; class This implements Prototype,Command { public Object clone() { return new This(); } public String getName() { return &quot;This&quot;; } public void execute() { System.out.println(&quot;This:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt; class That implements Prototype,Command { public Object clone() { return new That(); } public String getName() { return &quot;That&quot;; } public void execute() { System.out.println(&quot;That:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt; class TheOther implements Prototype,Command { public Object clone() { return new TheOther(); } public String getName() { return &quot;TheOther&quot;; } public void execute() { System.out.println(&quot;TheOther:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt;`public class PrototypeDemo { //3\. Populate the &quot;registry&quot; public static void initializePrototypes() { PrototypesModule.addPrototype(new This()); PrototypesModule.addPrototype(new That()); PrototypesModule.addPrototype(new TheOther()); } public static void main(String[] args) { initializePrototypes(); Object[] objects = new Object[9]; int total = 0; // 6\. Client does not use &quot;new&quot; for(int i=0;i&amp;lt;args.length;i++) { objects[total] = PrototypesModule.findAndClone(args[i]); if(objects[total]!=null) total++; } for(int i=0;i&amp;lt;total;i++) { ((Command)objects[i]).execute(); } } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Prototype Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singleton设计模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F19%2Fsingleton-e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[参考Efficetive Java page14深入浅出单实例Singleton设计模式如何正确地写出单例模式 Singleton 1.0版本 public class Singleton { private static Singleton instance =null; private Singleton() { System.out.println("Singleton 实例化"); } public static Singleton getInstance() { if(instance==null){ instance = new Singleton(); } return instance; } } Singleton的特点 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。 所形成的实例保存在自己类中的私有成员中。 我们取实例时，只需要使用Singleton.getInstance()就行了。 单线程下测试代码： public class Tests { public static void main(String[] args) { for(int i=1;i]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRASP通用职责分配软件模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F18%2Fgrasp-e9-80-9a-e7-94-a8-e8-81-8c-e8-b4-a3-e5-88-86-e9-85-8d-e8-bd-af-e4-bb-b6-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[GRASP设计模式及OO设计原则 GRASP设计模式的全称是General Responsibility Assignment Software Patterns，即通用职责分配软件模式。它定义了9个基本的OO设计原则或基本的设计构件。这9个设计模式分别是： 控制器(Controller) 创建者(Creator) 高内聚(High cohesion) 间接性(Indirection) 信息专家(Information expert) 低耦合(Low coupling) 多态(Polymorphism) 预防变化(Protected variations) 纯虚构(Pure fabrication) 1.The Controller pattern the controller collaborates with the bussiness objects to handle the actor request the controller delivers the result to the presentation,which displays the result to the actor 为了解决如下问题(a solution to these problems)A. Decouple the presentation and bussiness objects B. Remove the responsibility to handle an actor request from the presentation and assign it to another object 缺点(liabilities)A controller may be assigned too many responsibilities,resulting in a so-called bloated controller 2.Creator the creator is the object that is responsible for creating an object of a class a solution to these problems,supposed that an object of class A is the creator of an object of class BA. Class A is an aggregation(聚合) of class BB. An object of class A contains objects of class BC. An object of class A records object of class BD. An object of class A closely uses objects of class BE. An object of class A has the information to create objects of class B 缺点(liabilities)One same object may have different creation behaviors 3 6 High cohesion Low coupling4 Indirection间接性模式关注这样一个问题：为了避免两个或多个事务之间直接耦合，应该如何分配职责？如何使对象解耦合，以支持低耦合并提高复用性潜力？ 间接性模式对此的回答是：将职责分配给中介对象，使其作为其他构件或服务之间的媒介，以避免它们之间的直接耦合。中介则实现了其他构件之间的间接性。 间接性模式的思想比较简单，即通过一个中介就能消除许多的耦合。在GoF的23种设计模式中，有许多模式都利用到了间接性的思想。比如桥接模式中，设计将抽象部分与其实现部分相分离，利用的就是在客户与实现之间增加了一个抽象层次。外观模式则是在整个子系统与客户之间增加了一个便于用户使用的外观类作为中介。而中介者模式中的中介者则更是典型的例子。 5 The expert pattern the expert is the object that is responsible for handling a request should have the information to fulfill the request a solution to these problemsA. who should be assigned the responsibility to handle a request B. Remove the excessive responsibility from the controller and assigning them to other objects 缺点(liabilities)The expert may become a big object 7 多态(Polymorphism)8 预防变化(Protected variations)防止变异模式关注这样一个问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？ 防止变异模式的回答是：识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定的接口。 防止变异（PV）是非常重要和基本的软件设计原则，几乎所有的软件或架构设计技巧都是防止变异的特例。PV是一个根本原则，它促成了大部分编程和设计的模式和机制，用来提供灵活性和防止变化。在软件设计中，除了数据封装、接口、多态、间接性等机制是PV的核心机制之外，没有一种固定的或者是通用的办法能够防止一切变化的产生。因此PV的实现依赖的是一系列的OO设计方面的经验性原则，用以产生一个设计良好的高内聚、低耦合的系统，从而支持PV。 这里需要参考文章面向对象设计原则 9 纯虚构(Pure fabrication)纯虚构模式关注这样一个问题：当你并不想违背高内聚和低耦合或其他目标，但是基于专家模式所提供的方案又不合适时，哪些对象应该承担这一职责？ OO设计中的领域模型是对领域内的概念内或现实世界中的对象的模型化表示。创建领域模型的关键思想是减小软件人员的思维与软件模式之间的表示差异。因此，在OO设计时，系统内的大多数类都是来源于现实世界中的真实类。然而，在给这些类分配职责时，有可能会遇到一些很难满足低耦合高内聚的设计原则。纯虚构模式对这一问题给出的方案是：给人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，而代表虚构出来的事物，用以支持高内聚、低耦合和复用。 纯虚构模式强调的是职责应该置于何处。一般来说，纯虚构模式会通过表示解析或者行为解析来确定出一些纯虚构类，用于放置某一类职责。理想状况下，分配给这种虚构物的职责是要支持高内聚低耦合的，从而使整个系统处于一种良好的设计之中。 例如，在信息专家模式的最后一段所举的例子中提到，许多后台系统都需要对数据库进行操作，将系统中的一些对象进行持久化。信息专家模式给出的建议是将持久化的职责分配给具体的每一个模型类。但是这种建议已经被证明是不符合高内聚低耦合原则的，因为不会被采纳。于是，设计者往往会在系统中加入类似于DAO或者PersistentStorage这样的类。这些类在领域模型中是并不存在的，它们完全由设计者根据系统的行为而虚构得到。然而，这些类的引入，使得操作数据库进行持久化这种高内聚的职责可以顺理成章地分配给它们。从而在整个系统中实现了比较好的内聚和耦合。 在使用纯虚构模式时，不能毫无限制地对系统中的各种行为进行解析并纯虚构。如此往往会导致系统中大量的行为对象的存在，这样会对耦合产生不良的影响。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>GRASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP使用]]></title>
    <url>%2Fblog%2F2016%2F04%2F13%2Fjsp-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Jsp网页的组成模板数据静态部分，web容器不作处理，如HTML标签。 元素 脚本元素 指令元素 动作元素 Jsp 脚本元素类型脚本元素脚本语法 声明 &lt;%! 声明%&gt; 脚本 &lt;% 脚本%&gt; 脚本表达式 &lt;%= 脚本表达式%&gt; 说明：各个脚本类型的普通格式都有其对应的XML兼容格式，其区别在于：对普通格式页面的访问，会以HTML文件的形式显示，而访问对应的XML兼容格式时，会以XML文件的形式显示。 &lt;%!声明%&gt;声明语句用于声明方法和变量，对应的XML兼容格式为 &ltjsp:declaration&gt&lt/jsp:declaration&gt `&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HelloWorld&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;%! public long fact(long x){//声明 if(x == 0) return 1; else return x * fact(x - 1); } %&amp;gt; &amp;lt;table border=&quot;1&quot;&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;x&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;x!&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;% for(long i = 0; i &amp;lt; 20; i++){ %&amp;gt;&amp;lt;!--脚本--&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;%=i %&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;%=fact(i) %&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;%} %&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;` `&lt;/pre&gt; // 在声明中定义的变量是翻译成相应Java程序的成员变量, 在脚本中定义的变量是相应Java程序的局部变量。 * * * * * * &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; ## &lt;%脚本%&gt; &lt;/body&gt; &lt;/html&gt; 普通格式` 在&lt;%%&gt;标签里面写入Java代码，访问时以HTML文件的形式呈现。 '&lt;html&gt; &lt;head&gt;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String str = "HelloWorld"; out.println(str); %&gt; &lt;/body&gt; &lt;/html&gt;' 说明：脚本翻译成对应java程序的代码放在该java程序的_jspService()方法中，因此，在脚本中声明的变量是局部变量。 ` XML兼容格式 ` 在&lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt;标签间写入Java代码，访问时以XML文件的形式呈现。 示例： '&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" xmlns="http://www.w3.org/1999/xhtml" version="2.0"&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Simple jspx page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:scriptlet&gt; String str = "hello" ; out.println(str) ; &lt;/jsp:scriptlet&gt; &lt;/body&gt; &lt;/html&gt; &lt;/jsp:root&gt;' ` ## ` 脚本表达式用来显示动态生成的结果，对应的XML兼容格式为&lt;jsp:expression&gt;&lt;/jsp:expression&gt;。不能使用分号作为脚本表达式的结束符，脚本表达式可以是常量，也可以是动态计算出来的值。 示例： '&lt;html&gt; &lt;head&gt;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String str = "Hello World"; %&gt; &lt;%=str %&gt; &lt;/body&gt; &lt;/html&gt;' 说明：脚本表达式翻译成对应java程序的代码放在该java程序的_jspService()方法中的print()方法中。 ` ## JSP页面的注释 &lt;%–注释内容–%&gt;//jsp注释，注释内容不会翻译为java代码，浏览器和源码中无法看到。 //HTML注释，会翻译为对应的java代码，在浏览器中注释的内容不会显示，查看源代码看得到注释的内容。&lt;%//%&gt;、&lt;%/**/%&gt;//java注释，会翻译为java代码,但是不作为响应的内容，浏览器和源码中无法看到。例子&#39;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HelloWorld&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;% String str = &quot;aaa&quot;; %&amp;gt; &amp;lt;%--&amp;lt;%=str %&amp;gt; --%&amp;gt; //jsp注释 &amp;lt;!--&amp;lt;%=str %&amp;gt; --&amp;gt; //HTML注释，无法在浏览器中看到，但可在网页源文件中看到&amp;lt;!--aaa--&amp;gt; &amp;lt;% //String str2 = &quot;bbb&quot;; %&amp;gt; //java注释 &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&#39; # JSP指令元素 JSP指令元素&amp;lt;%@指令类型 属性名=”属性值”%&amp;gt;用于提供整个JSP页面的相关信息，用来设定JSP页面的相关属性。## Page指令page指令的功能是设定整个JSP页面的属性和相关功能，用于翻译阶段与web容器的通讯。语法：&#x25;&#x40;&#112;&#97;&#103;&#101;&#23646;&#x6027;&#x540d;&#61;&#x201d;&#23646;&#24615;&#x503c;&#x201d;&#37;对应的xml兼容格式语法为：&lt;jsp:directive.page属性名=”属性值”/&gt;### Page指令的属性属性名描述默认值language脚本语言名称“java”info网页信息无contentTypeMIME类型及字符编码“text/html;charset=ISO-8859-1”import类和包nonebuffer缓冲区大小8192kautoFlush自动刷新truesession能否获取session对象trueisThreadSafe是否线程安全trueerrorPage指定错误页面noneisErrorPage允许为错误页面falseextends指定父类无例子&#39;&amp;lt;%@page contentType=&quot;text/html; charset=utf-8&quot; info=&quot;aa&quot; %&amp;gt; &amp;lt;!--翻译成的java代码为response.setContentType(“text/html;charset=utf-8”)--&amp;gt; &amp;lt;%@page import=&quot;java.util.Date&quot;%&amp;gt; &amp;lt;!--翻译成的java代码为import java.util.Date--&amp;gt; &amp;lt;%@page import=&quot;java.text.SimpleDateFormat&quot;%&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;pageTest&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;% Date date = new Date(); SimpleDateFormat sd = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); %&amp;gt; &amp;lt;h1&amp;gt;当前系统时间：&amp;lt;%=sd.format(date) %&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&#39;### include指令（静态包含）：include指令用于在JSP编译阶段插入一个包含文本或代码的文件，将文件中的文本静态地包含进当前JSP文件中，如：&lt;%@include file=”hello.jsp”%&gt;。静态包含的文本最好不要有HTML标签和body标签，因为被包含的文件的全部内容将被插入到JSP文件中include指令所在的地方，这些标签会同JSP文件中已有的同样的标签发生冲突，静态包含的文件名不能是变量名且不能传递参数。### taglib指令taglib指令能让用户在页面中使用自定义的标签。语法：&lt;%@taglib uri=”uri” prefix=”tagPrefix”%&gt;对应的xml兼容格式语法为：&lt;jsp:directive.taglib uri=”uri” prefix=”tagPrefix”/&gt;## JSP动作元素JSP动作利用XML语法格式的标记来控制Servlet引擎的行为。利用JSP动作可以动态地插入文件、重用JavaBean组件、重定向用户到另外的页面、为java插件生成HTML代码、实现页面与组件的通信。### &amp;lt;jsp:include/&amp;gt;动作(动态包含):语法: &amp;lt;jsp:include page=&quot;localUrl&quot; flush=&quot;true&quot;/&amp;gt;,flush为true表示缓冲区满时，自动刷新页面。### &amp;lt;jsp:forward/&amp;gt;动作（页面转发）：语法：&amp;lt;jsp:forward page=”url”/&amp;gt;，相当于RequestDispatcher的forward方法, 将请求转发出去。## 动态包含和静态包含的区别☆ 根本区别在于包含的时机，静态包含是在编译期间包含，而动态包含是在运行期间包含。☆ 静态包含的是代码，动态包含的只是响应的内容。☆ 静态包含适用于包含静态页面，动态包含适用于包含动态页面。☆ 静态包含不能传递参数，动态包含可以传递参数。① 、编写includeTest1.jsp如下： &amp;lt;body&amp;gt; &amp;lt;% int i=100; String str=&quot;includeTest1.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt;&amp;lt;br&amp;gt; &amp;lt;jsp:include page=&quot;includeTest2.jsp&quot;&amp;gt;&amp;lt;/jsp:include&amp;gt; &amp;lt;/body&amp;gt; 再编写includeTest2.jsp如下： &amp;lt;body&amp;gt; &amp;lt;% int i=600; String str=&quot;includeTest2.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt; &amp;lt;/body&amp;gt; 启动tomcat，在浏览器中输入http://localhost:8080/myapp/includeTest1.jsp查看结果如下： includeTest1.jsp中i值是：100 includeTest2.jsp中i值是：600 ② 、将includeTest1.jsp改为如下： &amp;lt;body&amp;gt; &amp;lt;% int i=100; String str=&quot;includeTest1.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt;&amp;lt;br&amp;gt; &amp;lt;%@ include file=&quot;includeTest2.jsp&quot;%&amp;gt; &amp;lt;/body&amp;gt; 将includeTest2.jsp改为如下： &amp;lt;body&amp;gt; &amp;lt;%=str%&amp;gt;中i值是：&amp;lt;%=i %&amp;gt; &amp;lt;/body&amp;gt; 在浏览器中输入：http://localhost:8080/myapp/includeTest1.jsp查看结果如下： includeTest1.jsp中i值是：100 includeTest1.jsp中i值是：100 ③ 、从上例可知，动态包含时，包含和被包含的文件互不影响，只是将被包含文件编译执行后的结果放入了包含的文件中；静态包含相当于将被包含的文件中的文本直接放入了包含的文件中，然后编译执行。## JSP隐式对象隐式对象就是不用实例化，可以直接在JSP页面中使用的对象，如下表所示： 对象 描述 request 代表与请求相关的HttpServletRequest对象 response 代表与响应相关的HttpServletResponse对象 PageContext 代表封装请求某个JSP页面时请求环境的PageContext对象 session 代表特定用户请求会话的HttpSession对象 application 代表web应用程序的ServletContext对象 out 代表与响应输出流相关的jspWriter对象 config 代表JSP页面的Servlet相关的ServletConfig对象 page 等于java中的this变量 exception JSP页面抛出的Throwable对象，这个对象只能在JSP错误页面中使用 ### out对象out对象是一个输出缓冲流，用来给客户端返回信息，它是javax.servlet.jsp.JspWriter的一个实例。out对象常用方法：☆println()：向客户端输出各种类型的数据☆newLine()：输出一个换行符☆close()：关闭输出流☆flush()：输出缓冲区里的数据☆clearBuffer()：清除缓冲区里的数据，同时把数据输出到客户端☆clear()：清除缓冲区里的数据，但不把数据输出到客户端☆getBufferSize()：返回缓冲区的大小### pageContext对象：pageContext对象可以获取其他隐式对象、可以实现页面的转发和包含、可以用它对四个作用域空间进行数据的存取，它是javax.servlet.jsp.PageContext的实例。① pageContext对象获取其他隐式对象：☆getRequest ：获得request隐式对象☆getResponse：获得response隐式对象☆getServletConfig：获得config隐式对象☆getServletContext：获得application隐式对象☆getPage：获得page隐式对象☆getSession：获得session隐式对象②pageContext对象对四个作用域空间进行数据的存取：pageContext对象提供了四个常量，用来表示四个作用域：☆PAGE_SCOPE：pageContext作用域，只在当前页面有效☆REQUEST_SCOPE： request作用域，在forward转发的页面有效☆SESSION_SCOPE：session作用域，IE浏览器未关闭就一直有效☆APPLICATION_SCOPE：application作用域，未重启Tomcat就一直有效。③pageContext对象实现页面的转发和包含：pageContext.forward(String relativeURL);//实现页面的转发pageContext.include(String relativeURL);//实现页面的包含例子`例1，获取web.xml配置文件中jsp的初始化参数：先在tomcat安装目录下的webapps目录中新建/myapp/WEB-INF/路径，并在WEB-INF目录中编写web.xml如下：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;web-app version=”2.5” xmlns=”http://java.sun.com/xml/ns/javaee“ xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance“ xsi:schemaLocation=”http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&amp;gt; &lt;servlet&gt; &lt;servlet-name&gt;param&lt;/servlet-name&gt; &lt;jsp-file&gt;/get.jsp&lt;/jsp-file&gt;&lt;!–指定jsp文件，路径相对于当前web项目文件夹–&gt; &lt;init-param&gt;&lt;!–JSP的初始化参数–&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhangsan&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;param&lt;/servlet-name&gt; &lt;url-pattern&gt;/get.jsp&lt;/url-pattern&gt;!--http://localhost:8080/myapp/get.jsp对应该jsp-- &lt;/servlet-mapping&gt;&lt;/web-app&gt;然后在myapp目录中编写get.jsp如下：&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;%&gt;&lt;html&gt; &lt;head&gt; &amp;lt;base href=&quot;&amp;lt;%=basePath%&amp;gt;&quot;&amp;gt; &amp;lt;!--base标签设置当前页面的根路径，即当前页面的其他路径可以相对base标签设置的路径而设置--&amp;gt; &amp;lt;title&amp;gt;My JSP &apos;forward.jsp&apos; starting page&amp;lt;/title&amp;gt; &lt;%! public void jspInit() {//访问该jsp时执行该方法 System.out.println(&quot;初始化&quot;); }public void jspDestroy() {//该jsp对应的Java程序(servlet)销毁时执行 System.out.println(&quot;销毁&quot;); }%&gt; &lt;/head&gt;&lt;body&gt;&lt;% String param = config.getInitParameter(&quot;name&quot;); //获取web.xml中jsp的初始化参数 out.println(&quot;param-value in web.xml is :&quot;+param); %&gt;&lt;br/&gt; basePath is &amp;lt;%=basePath%&amp;gt; &lt;/body&gt;&lt;/html&gt;最后启动tomcat，在浏览器中输入：http://localhost:8080/myapp/get.jsp访问。` `例2，在request作用域中传递绑定的对象：先在tomcat安装目录下的webapps目录中新建myapp目录，然后在myapp目录中编写sendEmp.jsp如下：&lt;html&gt;&lt;body&gt;&lt;%request.setAttribute(“emp”,”scott”);%&gt; &amp;lt;jsp:forward page=&quot;getEmp.jsp&quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;&amp;lt;!--请求转发--&amp;gt; &lt;/body&gt;&lt;/html&gt;继续在myapp目录中编写getEmp.jsp如下：&lt;%String emp = (String)pageContext.getAttribute(“emp”,PageContext.REQUEST_SCOPE);String emp2 = (String)request.getAttribute(“emp”);//这句和上句意思一样out.println(emp+” “+emp2);%&gt;启动tomcat，在浏览器中输入：http://localhost:8080/myapp/sendEmp.jsp访问。 ##另外]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2Fblog%2F2016%2F04%2F13%2Fe9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e8-ae-be-e8-ae-a1-e5-8e-9f-e5-88-99%2F</url>
    <content type="text"><![CDATA[一些软件设计的原则面向对象设计原则和创建SOLID应用的5个方法 迪米特法则定义： 一个对象应该对其它对象保持最少的了解 从而降低类之间的耦合 具体来说对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法： 对象O 与O直接相关的Component Object 由方法M创建或者实例化的对象 作为方法M的参数的对象例子：demeter SOLID 原则单一职责 （SRP)一个类发生变化的原因不应该超过一个。这意味着代码中每个类，或者类似的结构只有一个功能。 里氏替换原则 （LSP)子类必须能够替换成它们的基类。即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。A. Derived types must be completely substitutable for their base typesB. This principle is just an extension of the Open Close PrincipleC. Making sure that new derived classes are extending the base classes withoutchanging their behavior 正方形不是矩形的例子 接口隔离原则 （ISP)接口隔离原则(Interface Segregation Principle)指出客户不应该被强迫依赖于他们不使用的接口。当我们使用非内聚的接口时，ISP指导我们创建多个较小的内聚度高的接口。 当你应用ISP时，类和他们的依赖使用紧密集中的接口通信，最大限度地减少了对未使用成员的依赖，并相应地降低耦合度。小接口更容易实现，提升了灵活性和重用的可能性。由于很少的类共享这些接口，为响应接口的变化而需要变化的类数量降低，增加了鲁棒性。 A. Clients should not be forced to depend upon interfaces that they don’t use 依赖反转原则 （DIP)依赖反转原则(Dependency Inversion Principle,DIP)指出高层次模块不应该依赖于低层次模块；他们应该依赖于抽象。第二，抽象不应该依赖于细节；细节依赖于抽象。方法是将类孤立在依赖于抽象形成的边界后面。如果在那些抽象后面所有的细节发生变化，那我们的类仍然安全。这有助于保持低耦合，使设计更容易改变。A. High-level modules should not depend on low-level modules. Both shoulddepend on abstractionsB. Abstractions should not depend on details. Details should depend onabstractions 开闭原则（OCP)关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 A. Software entities like classes, modules and functions should be open forextensionbut closedformodificationsB. The design and writing of the code should be done in a way that newnctionality should be added with minimum changes in the existing codeC. The design should be done in a way to allow the adding of new functionality asnew classes, keeping as much as possible existing code unchanged 其它原则参考第一个链接一些软件设计的原则 Common Closure Principle（CCP）– 共同封闭原则 Common Reuse Principle (CRP) – 共同重用原则 Hollywood Principle – 好莱坞原则 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 Convention over Configuration（CoC）– 惯例优于配置原则 Separation of Concerns (SoC) – 关注点分离 Design by Contract (DbC) – 契约式设计 Acyclic Dependencies Principle (ADP) – 无环依赖原则 Don’t Repeat Yourself (DRY) Keep It Simple, Stupid (KISS) Program to an interface, not an implementation Command-Query Separation (CQS) – 命令-查询分离原则 You Ain’t Gonna Need It (YAGNI)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用]]></title>
    <url>%2Fblog%2F2016%2F04%2F11%2Fmarkdown-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Markdown语法说明Markdown入门 Test这是一个html书写的表格 标题1标题2data1data2 Sum $180 &copy; This is an H1This is an H2这是H1这是H2这是H3这是H6 这是一段区块引用 This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题 这是第一行列表项 这是第二行列表项 给出一些例子代码：return shell_exec(“echo $input | $markdown_script”); markdown 支持有序列表和无序列表无序列表使用星号 加号或减号作为列表标记 Red Green Blue Red Green Blue Red Green Blue 有序列表使用数字接着一个英文句点 Bird McHale Parish Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is paragraph oneThis is paragraph one……. This is paragraph two 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 分割 分割 分割 This is an example inline link. 插入图片 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。这里是粗体 这里是斜体 代码‘Class Main{}’]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2Fblog%2F2016%2F04%2F11%2Fgit-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c%2F</url>
    <content type="text"><![CDATA[图解Git参考廖雪峰的Git教程Git分支管理初始化一个Git仓库，使用git init命令 添加文件到仓库： 1 使用git add 可反复添加多个文件 2 使用git commit -m “information” git status查看仓库状态 git diff filename 查看文件改动地方 git log查看历史纪录 git log –pretty=oneline 在Git中，用HEAD表示当前版本，也就是最新的提交 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 使用git reset –hard HEAD^回退到上个版本 其后也可以加版本号回退 Git提供了一个命令git reflog用来记录你的每一次命令 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 当使用git add filename 之后再回退可以使用 git reset HEAD filenamegit commit 之后需要版本回退 git reset –hard HEAD^ 或git reset –hard commit_id 删除文件： 用命令git rm删掉，并且git commit 用git checkout – filename 从版本库中还原到工作区远程仓库：]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆]]></title>
    <url>%2Fblog%2F2015%2F10%2F17%2Fe8-ae-b0-e5-bf-86%2F</url>
    <content type="text"><![CDATA[只如初见]]></content>
      <categories>
        <category>只如初见</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[世界，你好！]]></title>
    <url>%2Fblog%2F2015%2F10%2F17%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！]]></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
</search>
