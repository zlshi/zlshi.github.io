<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2021%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统下Vim、Tmux 、Git、Zsh的配置与使用]]></title>
    <url>%2Fblog%2F2021%2F04%2F07%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8BVim%E3%80%81Tmux-%E3%80%81Git%E3%80%81Zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JNI使用示例]]></title>
    <url>%2Fblog%2F2021%2F04%2F07%2FJNI%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[转载于http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html#step5 JNI lets Java code use code and code libraries written in other languages, such as C and C++. The Invocation API, which is part of JNI, can be used to embed a Java virtual machine (JVM) into native applications, thereby allowing programmers to call Java code from within native code. This tutorial deals with the two most common applications of JNI: calling C/C++ code from Java programs, and calling Java code from C/C++ programs. We’ll cover both the essentials of the Java Native Interface and some of the more advanced programming challenges that can arise. 需要的工具和组件 A Java compiler: javac.exe ships with the SDK. A Java virtual machine (JVM): java.exe ships with the SDK. A native method C file generator: javah.exe ships with the SDK. Library files and native header files that define JNI. The jni.h C header file, jvm.lib, and jvm.dll or jvm.so files all ship with the SDK. A C and C++ compiler that can create a shared library. The two most common C compilers are Visual C++ for Windows and cc for UNIX-based systems. 即需要安装Java development kit C或者C++的编译器，本实验使用jdk1.8 ubuntu14.04操作系统 GCC编译器。 Calling C/C++ code from Java programs（从Java程序中调用C/C++代码）&nbsp; &nbsp;]]></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL Event]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2FMySQL-Event%2F</url>
    <content type="text"><![CDATA[1.Event 简介MySQL的Event是在相应的时刻调用的过程式数据库对象，由MySQL的事件调度器(Event Scheduler)来管理。事件取代了原先只能由操作系统的计划任务来执行的工作，而且MySQL的事件调度器可以精确到每秒钟执行一个任务。 2. 查看当前是否开启event scheduler123i: show variables like '%event_scheduler%';ii: select @@event_scheduler;iii: show processlist; (是否有State为: Waiting for next activation的进程，User为event_scheduler) 第一种： 第二种： 第三种： 3. 启动和关闭event scheduler方法事件调度器由全局变量event_scheduler决定，它有三个可设定值： OFF ON DISABLED OFF: 事件调度器是关闭的，调度线程没有运行，并且在show processlist中不显示，默认值是OFF。 ON: 事件调度器是开启的，并且执行所有的调度事件，通过show processlist可以查看Waiting for next activation的进程。 DISABLED: 设置此值表示Event Scheduler是被禁止的，无法在MySQL运行状态下改变其值。 注意:在MySQL启动时如果在my.cnf设置了event_scheduler=ON|OFF|1|0时，就不能在运行时修改为DISABLED，如果设置event_scheduler=DISBALED时，就不能在运行时修改其值为ON|OFF|1|0。 启动Event:1234SET GLOBAL event_scheduler = ON;SET @@global.event_scheduler = ON;SET GLOBAL event_scheduler = 1;SET @@hlobal.event_scheduler = 1; 关闭Event:1234SET GLOBAL event_scheduler = OFF;SET @@global.event_scheduler = OFF;SET GLOBAL event_scheduler = 0;SET @@global.event_scheduler = 0; 4. 创建Event每个事件由两个主要部分组成，第一部分是事件调度(Event Scheduler)，表示事件何时启动以及按什么频率启动，第二部分是事件动作(Event Action)，是事件启动时执行的代码，事件动作可以是SQL语句、存储过程、begin…end语句块。 4.1 语法123456789101112131415161718192021CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] EVENT [IF NOT EXISTS] event_name ON SCHEDULE schedule [ON COMPLETION [NOT] PRESERVE] [ENABLE | DISABLE | DISABLE ON SLAVE] [COMMENT 'string'] DO event_body;schedule: AT timestamp [+ INTERVAL interval] ... | EVERY interval [STARTS timestamp [+ INTERVAL interval] ...] [ENDS timestamp [+ INTERVAL interval] ...]interval: quantity &#123;YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE | DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND&#125; 说明： DEFINER默认是当前创建Event的用户，服务器在执行该事件时，使用该用户来检查权限。 ON SCHEDULE 用来指定事件执行的时间和频率。 [ON COMPLETION [NOT] PRESERVE] 设置事件执行完毕后是否自动drop该事件，ON COMPLETION PRESERVE则不会被drop掉。 AT timestamp 表示在给定的timestamp或者datetime的时间执行一次 INTERVAL interval 表示从AT timestamp多久之后执行 EVERY interval 重复执行时间粒度 [ENABLE|DISABLE] 设置该事件创建后状态是否开启或关闭，默认为ENABLE 4.2 例子创建事件表events_list用来记录事件调度的名字和时间戳，然后创建Event每秒执行一次。 4.2.1 创建测试表 4.2.2 创建事件 查看事件执行结果： 5. 查看事件show events；显示当前库中的事件。 6. 修改事件通过alter event语句可以修改事件的定义和属性，可以使一个事件成为停止的或者再次让它活动，也可以修改一个事件的名字或者整个调度，然而当使用ON COMPLETION NOT PRESERVE属性定义的事件最后一次执行后，事件就会被删除，不能修改。 6.1 语法12345678910ALTER [DEFINER = &#123; user | CURRENT_USER &#125;] EVENT event_name [ON SCHEDULE schedule] [ON COMPLETION [NOT] PRESERVE] [RENAME TO new_event_name] [ENABLE | DISABLE | DISABLE ON SLAVE] [COMMENT 'string'] [DO event_body] 比如： 修改上面创建的事件为每一分钟执行一次123alter event event_every_second on scheduleevery 1 minutedo insert into events_list values('event_now', now()); 修改事件为不再活动 1alter event event_every_second disable; 7. 删除事件语法：1DROP EVENT [IF EXISTS] event_name ======================================================================== 通过使用Event 机制可以完成一些数据库的定时操作，比如分区表的自动管理，将在分区表中进行介绍。 Reference: https://blog.csdn.net/JesseYoung/article/details/35257527 &lt;http://www.simlinux.com/2014/08/19/mysql-event-scheduler.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2Fblog%2F2017%2F11%2F21%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[参考自jenkov java-reflection Classes使用Java反射，可以在运行时检查Java类。在使用Reflection时，可以从Classes获取以下信息： Class Name Class Modifies(public,private,synchronized etc.) Package Info Superclass Implemented Interfaces Constructors Methods Fields Anonotations 更具体的API列表参见JavaDoc The Class ObjectJava中所有类型（包括int,long,float等原始类型、数组）均有相关的Class对象，如果你在编译阶段知道某个类的名字，则可以使用如下方法获得这个Class对象：1Class myObjectClass = MyObject.class 如果在编译阶段不知道类的名字，但在运行阶段有类的名字，可以使用如下方法得到Class对象:12String className = ...//obtain class name as string at runtimeClass class = Class.forName(className) 当使用Class.forName()方法的时候，必须提供全路径的类名（包括包名），此方法在classpath下找不到指定的类时，会抛出ClassNotFoundException异常。 Class Name从Class对象中获取其名字有两种方法，分别是getName()和getSimpleName()，其中getName()方法包括包名，getSimpleName()没有包名。123Class aClass = ... //obtain Class object. see The Class Object sectionString className = aClass.getName();String simpleClassName = aClass.getSimpleName(); Modifiers使用Class对象可以知道类的public private static等信息。12Class aClass = ...//obtain Class object. See prev. sectionint modifiers = aClass.getModifiers(); 信息被存储在返回的int型modifier中的二进制位上，使用java.lang.reflect.Modifier提供的方法来测试。123456789101112Modifier.isAbstract(int modifiers)Modifier.isFinal(int modifiers)Modifier.isInterface(int modifiers)Modifier.isNative(int modifiers)Modifier.isPrivate(int modifiers)Modifier.isProtected(int modifiers)Modifier.isPublic(int modifiers)Modifier.isStatic(int modifiers)Modifier.isStrict(int modifiers)Modifier.isSynchronized(int modifiers)Modifier.isTransient(int modifiers)Modifier.isVolatile(int modifiers) Package Info使用Class对象也可以获得包信息：12Class aClass = ... //obtain Class object. See prev. sectionPackage package = aClass.getPackage(); 可以使用Package对象获得包的相关信息，具体参看java.lang.package Superclass获得当前Class对象的Superclass对象的方法如下：1Class superclass = aClass.getSuperclass(); Implemented Interfaces得到类实现的接口列表的方法如下：12Class aClass = ... //obtain Class object. See prev. sectionClass[] interfaces = aClass.getInterfaces(); 会返回当前类中声明实现的接口列表，对于父类中实现的接口而在子类中未声明实现，则不会返回到接口列表中，如果要获得当前类实现的所有接口列表需要递归父类的接口列表进行合并。 Constructors获得构造器的方法如下：1Constructor[] constructors = aClass.getConstructors(); 对构造器的说明将在下面章节中更详细的介绍。 Methods获得方法列表的方法如下：1Method[] method = aClass.getMethods(); 更详细的说明见下面Methods章节。 Fields获得域列表的方法如下：1Field[] method = aClass.getFields(); 更详细的说明见下面Fields章节。 Annotations获得注解列表的方法如下：1Annotation[] annotations = aClass.getAnnotations(); 更详细的说明见下面Annotations章节。 ConstructorsObtaining Constructor Objects使用Class对象可以得到Constructor对象：12Class aClass = ...//obtain class objectConstructor[] constructors = aClass.getConstructors(); 会返回类中所有声明的public构造器，如果已知构造i器的参数个数和类型，则可以获得具体的构造器。比如：12Class aClass = ...//obtain class objectConstructor constructor = aClass.getConstructor(new Class[]&#123;String.class&#125;); 如果没有匹配参数的构造器，则会抛出NoSuchMethodException异常。 Constructor Parameters通过getParameterTypes()方法得到Constructor的参数列表：12Constructor constructor = ...// obtain constructor -see aboveClass [] parameterTypes = constructor.getParameterTypes(); Instantiating Objects using Constructor Object使用Constructor初始化对象:1234//get constructor that takes a String as argumentConstructor constructor = MyObject.class.getConstructor(String.class);MyObject myObject = (MyObject) constructor.newInstance("constructor-arg1"); Constructor.newInstance()方法根据指定的参数创建对象。 Fields使用Java反射你可以在运行时得到类的成员变量并进行get/set。 Obtaining Field Objects12Class aClass = ...//obtain class objectField[] fields = aClass.getFields(); 返回的Field[]数组包含类中所有的public成员变量。 如果知道成员变量的名字，则可以使用getField()和getDeclaredField()方法获得成员变量对象。123Class aClass = MyObject.classField field = aClass.getField("someField");Field otherField = aClass.getDeclaredField("someField") 如果没有指定名字的成员变量会抛出NoSuchFieldException异常。getField(String name)与getDeclaredField(String name)的区别是getField只能返回public的成员变量，而getDeclaredField还可以返回private修饰的成员变量。 Field Name使用Field对象获得成员变量名字的方法如下：12Field field = ...//obtain field objectString fieldName = field.getName(); Field Type得到成员变量类型的方法如下：12Field field = aClass.getField("someField");Object fieldType = field.getType(); Getting and Setting Field Values当我们得到Field对象时，就可以使用Field.get()和Field.set()方法来获得和设置成员变量的值。123456Class aClass = MyObject.classField field = aClass.getField("someField");MyObject objectInstance = new MyObject();Object value = field.get(objectInstance);field.set(objectInstance,value); 如果是一个static的成员，则Field的get和set方法传null作为参数。 MethodsObtaining Method Objects12Class aClass = ...//obtain class objectMethod[] methods = aClass.getMethods(); 返回类中定义的public方法列表。如果知道方法的名字和参数列表，则可以使用getMethod()直接得到Method对象。123Class aClass = ...//obtain class objectMethod method = aClass.getMethod("doSomething", new Class[]&#123;String.class&#125;); 如果没有找到则会抛出NoSuchMethodException异常。如果方法没有参数，则传递null123Class aClass = ...//obtain class objectMethod method = aClass.getMethod("doSomething", null); Method Parameters and Return Types通过Method对象获得方法的参数列表12Method method = ... // obtain method - see aboveClass[] parameterTypes = method.getParameterTypes(); 得到返回类型：12Method method = ... // obtain method - see aboveClass returnType = method.getReturnType(); Invoking Methods using Method Object使用Method对象调用类想对应的方法。1234//get method that takes a String as argumentMethod method = MyObject.class.getMethod("doSomething", String.class);MyObject instance = new MyObject();Object returnType = method.invoke(instance,"parameter-value1") method.invoke的第一个参数为需要在哪个实例上调用的method方法的对象，弱如果是static修饰的方法则此参数传递null即可。 Getters and SettersJava反射无法直接得到类的Getter和Setter方法，但可以通过遍历Method[]数组，根据Getter和Setter方法的特征得到。具体特征约定如下： Getter0参数，并且方法名以get开头。 Setter1个参数，并且方法名以set开头。 下面是实现举例：1234567891011121314151617181920public static void printGettersSetters(Class aClass)&#123; Method[] methods = aClass.getMethods(); for(Method method: methods)&#123; if(isGetter(method)) System.out.println("getter: "+method); if(isSetter(method)) System.out.println("setter: "+method); &#125;&#125;public static boolean isGetter(Method method)&#123; if(!method.getName.startsWith("get")) return false; if(method.getParameterTypes().length !=0) return false; if(void.class.equals(method.getReturnType()) return false; return true;&#125;public static boolean isSetter(Method method)&#123; if(!method.getName().startsWith("set")) return false; if(method.getParameterTypes().length != 1) return false; return true;&#125; Private Fields and MethodsAccessing Private Fields访问private field需要使用Class.getDeclaredField(String name)或者Class.getDeclaredFields()方法。Class.getField(String name)和Class.getFields()方法只会返回公有域public field。例如：123456public class PrivateObject&#123; private String privateString = null; public PrivateObject(String privateString)&#123; this.privateString = privateString; &#125;&#125; 12345678PrivateObject privateObject = new PrivateObject("The Private Value");Field privateStringField = PrivateObject.class.getDeclaredField("privateString");privateStringField.setAccessible(true);String fieldValue = (String) privateStringField.get(privateObject);System.out.println("fieldValue = " + fieldValue); //will print "The Private Value" Accessing Private Methods访问private method使用Class.getDeclaredMethod(String name, Class[] parameterTypes) 或者Class.getDeclaredMethods()123456789101112public class PrivateObject &#123; private String privateString = null; public PrivateObject(String privateString) &#123; this.privateString = privateString; &#125; private String getPrivateString()&#123; return this.privateString; &#125;&#125; 1234567891011PrivateObject privateObject = new PrivateObject("The Private Value");Method privateStringMethod = PrivateObject.class. getDeclaredMethod("getPrivateString", null);privateStringMethod.setAccessible(true);String returnValue = (String) privateStringMethod.invoke(privateObject, null);System.out.println("returnValue = " + returnValue); //will print "The Private Value" AnnotationsWhat are Java Annotations?Annotation是一种在Java代码中插入的注释或元数据，这些注释可以在编译时通过预编译工具进行处理，也可以在运行时通过反射进行处理。123@MyAnnotation(name="someName", value ="Hello World")public class TheClass&#123;&#125; TheClass类具有@MyAnnotation的注释，注释像接口一样定义。1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation&#123; public String name(); public String value();&#125; interface前的@表明是定义Annotation@Retention(RetentionPolicy.RUNTIME)表示注释在运行时可以通过反射来访问，如果没有指定，则注释在运行时不会保留。@Target(ElementType.TYPE)表示注释只能用于类型（类和接口）的顶部，也可以指定用于方法和成员变量。 Java Annotations PurposesJava注解用于以下目的: Compiler instructions Build-time instructions Runtime instructions Annotation Basics一个简单的注解如下所示：1@Entity @告诉编译器这是一个注解，@之后为注解的名字，这里为Entity Annotation Elements注解可以包含可以为其设置值的元素，元素就像一个属性或参数。1@Entity(tableName = "vehicles") 在上面的例子中包含了一个名为tableName的元素，并且设置其值为vehicles。元素需要被括号包在其中，如果注解没有元素，则不需要后面的括号。 一个注解可以包含多个元素1@Entity(tableName="vehicles", primaryKey="id") 如果一个注解只包含一个元素，则可以将其命名为value1@InsertNew(value="yes") 如果一个注解只包含一个名为value的元素，则可以省略名字1@InsertNew("yes") Annotation Placement注解可以放在classes、interfaces、methods、methods parameters、fields and local variables。 123@Entitypublic class Vehicle&#123;&#125; 表示在类上的一个名为Entity的注解。下面为在class fields methods parameters and local variables上的注解12345678910111213141516171819202122232425262728293031// class@Entity public class Vehicle &#123; // field @Persistent protected String vehicleName = null; //method @Getter public String getVehicleName() &#123; return this.vehicleName; &#125; //method parameter public void setVehicleName(@Optional vehicleName) &#123; this.vehicleName = vehicleName; &#125; public List addVehicleNameToList(List names) &#123; // local variable @Optional List localNames = names; if(localNames == null) &#123; localNames = new ArrayList(); &#125; localNames.add(getVehicleName()); return localNames; &#125;&#125; Built-in Java AnnotationsJava有三类compiler instructions的注解，分别是： @Deprecated @Override @SupressWarnings @Deprecated@Deprecated注解用来表明class method 或者field 被弃用，不应该再被使用，如果代码中使用这些被弃用的类、方法、或域则编译器会给出warning。123@Deprecatedpublic class MyComponent&#123;&#125; 在使用@Deprecated注解的时候，最好和Java注释一起使用，说明被弃用的原因，以及替代的新类、方法或域。1234567@Deprecated/** @deprecated Use MyNewComponent instead.*/public class MyComponent &#123;&#125; @Override@Override在方法上使用，用来表示对父类同名方法的重写覆盖。如果方法与父类中找不到同名方法，使用@Override编译器会给出错误。 在覆盖父类的方法时，@Override注解不是必须的，但建议加上，防止父类修改同名方法，子类未加@Override注解发现不了。123456789101112131415public class MySuperClass &#123; public void doTheThing() &#123; System.out.println("Do the thing"); &#125;&#125;public class MySubClass extends MySuperClass&#123; @Override public void doTheThing() &#123; System.out.println("Do it differently"); &#125;&#125; @SuppressWarnings@SuppressWarnings可以略过编译器的警告。12345@SuppressWarningspublic void methodWithWarning() &#123;&#125; Creating Your Own Annotations123456789@interface MyAnnotation &#123; String value(); String name(); int age(); String[] newNames();&#125; 上面定义了一个包含四个元素的注解，关键字@interface向编译器表明这是注解的定义。注解中的元素由数据类型和名字组成，类似interface接口中的抽象方法。但数据类型只能是基本数据类型或者是基本数据类型的数组，而不能是复杂对象。 使用上面注解的例子如下：12345678910@MyAnnotation( value="123", name="Jakob", age=37, newNames=&#123;"Jenkov", "Peterson"&#125;)public class MyClass &#123;&#125; Element Default Values定义注解时，可以为其中的元素指定默认值，这样在添加注解时可以省略具有默认值的元素。123456789@interface MyAnnotation &#123; String value() default ""; String name(); int age(); String[] newNames();&#125; value元素指定了默认值，所以可以不用给它赋值。123456789@MyAnnotation( name="Jakob", age=37, newNames=&#123;"Jenkov", "Peterson"&#125;)public class MyClass &#123;&#125; @Retention定义该注解的生命周期，表示在什么级别保留此信息。 RetentionPolicy.SOURCE – 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS – 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。（默认值） RetentionPolicy.RUNTIME– 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 12345678910import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123; String value() default "";&#125; @Target 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。 ElementType.TYPE:用于描述类、接口或enum声明 注解 ElementType.FIELD:用于描述实例变量 ElementType.METHOD:方法声明 ElementType.PARAMETER:参数声明 ElementType.CONSTRUCTOR:构造器的声明 ElementType.LOCAL_VARIABLE:局部变量声明 ElementType.ANNOTATION_TYPE 另一个注释(ANNOTATION_TYPE目标意味着注释只能用于注释其他注释。像@Target和@Retention注释一样。) ElementType.PACKAGE 用于记录java文件的package信息。 import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Target({ElementType.METHOD}) public @interface MyAnnotation { String value(); } @Inherited允许子类继承父类中的注解 java.lang.annotation.Inherited @Inherited public @interface MyAnnotation{ } @MyAnnotation public class MySuperClass {...} public class MySubClass extends MySuperClass {...} MySubClass可以继承MySuperClass的注解，因为声明了@Inherited @Documented一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。123456import java.lang.annotation.Documented;@Documentedpublic @interface MyAnnotation &#123;&#125; 12@MyAnnotationpublic class MySuperClass &#123; ... &#125; 当为MySuperClass类生成JavaDoc时， @MyAnnotation注解将会被包含进JavaDoc。 Java注解的例子和注解处理器等内容将在新的文章中讲解 (待补充) Class Annotations 使用反射可以在运行时得到类、方法、域变量的注解。 类：12345678910Class aClass = TheClass.class;Annotation[] annotations = aClass.getAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value()); &#125;&#125; 已知注解的名字还可以直接得到注解。12345678Class aClass = TheClass.class;Annotation annotation = aClass.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value());&#125; Method Annotations1234public class TheClass &#123; @MyAnnotation(name="someName", value = "Hello World") public void doSomething()&#123;&#125;&#125; 12345678910Method method = ... //obtain method objectAnnotation[] annotations = method.getDeclaredAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value()); &#125;&#125; 已知注解的名字：12345678Method method = ... // obtain method objectAnnotation annotation = method.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value());&#125; Parameter Annotations12345public class TheClass &#123; public static void doSomethingElse( @MyAnnotation(name="aName", value="aValue") String parameter)&#123; &#125;&#125; 1234567891011121314151617Method method = ... //obtain method objectAnnotation[][] parameterAnnotations = method.getParameterAnnotations();Class[] parameterTypes = method.getParameterTypes();int i=0;for(Annotation[] annotations : parameterAnnotations)&#123; Class parameterType = parameterTypes[i++]; for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("param: " + parameterType.getName()); System.out.println("name : " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value()); &#125; &#125;&#125; Method.getParameterAnnotations()返回一个二维Annotation数组，每个参数对应一个注解数组，所以返回二维Annotation数组。 Field Annotations12345public class TheClass &#123; @MyAnnotation(name="someName", value = "Hello World") public String myField = null;&#125; 12345678910Field field = ... //obtain field objectAnnotation[] annotations = field.getDeclaredAnnotations();for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value()); &#125;&#125; 已知注解的名字： 12345678Field field = ... // obtain method objectAnnotation annotation = field.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println("name: " + myAnnotation.name()); System.out.println("value: " + myAnnotation.value());&#125; 例子： 注解的定义： 测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.iaihe.Annotations;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * Created by zlshi on 17-11-23. */@MyAnnotation(name = "class",value="class annotation test")public class TheClass &#123; @MyAnnotation(name="field",value="field annotation test") public String myField = null; @MyAnnotation(name="method",value="method annotation test") public void doSomething()&#123; &#125; public static void doSomethingElse( @MyAnnotation(name="parameter",value="parameter annotation test") String parameter)&#123; System.out.println("somethinElse: "+parameter); &#125; public static void main(String[] args) throws Exception&#123; Class aClass = TheClass.class; //Class Annotations Annotation[] annotationss = aClass.getAnnotations(); for(Annotation annotation : annotationss) &#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation)annotation; System.out.println("name: "+myAnnotation.name()); System.out.println("value: "+myAnnotation.value()); &#125; &#125; System.out.println("=============================="); //Class Annotations Annotation annotation = aClass.getAnnotation(MyAnnotation.class); if(annotation instanceof MyAnnotation) &#123; MyAnnotation myAnnotation = (MyAnnotation)annotation; System.out.println("name: "+myAnnotation.name()); System.out.println("value: "+myAnnotation.value()); &#125; System.out.println("=============================="); //Method Annotations Method method = aClass.getDeclaredMethod("doSomething"); Annotation annotation1 = method.getAnnotation(MyAnnotation.class); if(annotation1 instanceof MyAnnotation) &#123; MyAnnotation myAnnotation = (MyAnnotation)annotation1; System.out.println("name: "+myAnnotation.name()); System.out.println("value: "+myAnnotation.value()); &#125; System.out.println("=============================="); //Parameter Annotations Method method1 = aClass.getDeclaredMethod("doSomethingElse", String.class); Annotation[][] parameterAnnotations = method1.getParameterAnnotations(); Class[] parameterTypes = method1.getParameterTypes(); int i = 0; method1.invoke(null,"Test somethingElse method"); for(Annotation[] annotations:parameterAnnotations) &#123; Class parameterType = parameterTypes[i++]; for(Annotation anno:annotations) &#123; if(anno instanceof MyAnnotation) &#123; MyAnnotation myAnnotation = (MyAnnotation)anno; System.out.println("param: "+parameterType.getName()); System.out.println("name: "+myAnnotation.name()); System.out.println("value: "+myAnnotation.value()); &#125; &#125; &#125; System.out.println("=============================="); //Field Annotations Field field = aClass.getDeclaredField("myField"); Annotation annotation2 = field.getAnnotation(MyAnnotation.class); if(annotation2 instanceof MyAnnotation) &#123; MyAnnotation myAnnotation = (MyAnnotation)annotation2; System.out.println("name: "+myAnnotation.name()); System.out.println("value: "+myAnnotation.value()); &#125; &#125;&#125; 运行结果： GenericsThe Generics Reflection Rule of Thumb使用Java泛型通常属于以下两种情况之一： Declaring a class/interface as being parameterizable.（声明类/接口是可参数化的） Using a parameterizable class.（使用可参数化的类） Generic Method Return Types12345678public class MyClass &#123; protected List&lt;String&gt; stringList = ...; public List&lt;String&gt; getStringList()&#123; return this.stringList; &#125;&#125; 可以获得getStringList()方法的返回值类型。123456789101112Method method = MyClass.class.getMethod("getStringList", null);Type returnType = method.getGenericReturnType();if(returnType instanceof ParameterizedType)&#123; ParameterizedType type = (ParameterizedType) returnType; Type[] typeArguments = type.getActualTypeArguments(); for(Type typeArgument : typeArguments)&#123; Class typeArgClass = (Class) typeArgument; System.out.println("typeArgClass = " + typeArgClass); &#125;&#125; 方法的返回值类型为泛型时，需要使用Method.getGenericReturnType()方法来获得返回类型。 例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package cn.iaihe.Generics;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.*;/** * Created by zlshi on 17-11-23. */public class MyClass &#123; protected List&lt;String&gt; stringList = Arrays.asList("test"); public List&lt;String&gt; getStringList() &#123; return this.stringList; &#125; public List&lt;?&gt; test() &#123; return new ArrayList&lt;&gt;(); &#125; public int testUnGeneric() &#123; return 0; &#125; public static void main(String[] args)throws Exception &#123; Method method1 = MyClass.class.getDeclaredMethod("getStringList"); Type type1 = method1.getReturnType(); //获取不到List里的String类型 System.out.println(type1); type1 = method1.getGenericReturnType(); System.out.println(type1); if(type1 instanceof ParameterizedType)&#123; ParameterizedType type = (ParameterizedType) type1; Type[] typeArguments = type.getActualTypeArguments(); for(Type typeArgument : typeArguments)&#123; Class typeArgClass = (Class) typeArgument; System.out.println("typeArgClass = " + typeArgClass); &#125; &#125; System.out.println("==================================="); Method method2 = MyClass.class.getMethod("test",null); Type type2 = method2.getGenericReturnType(); System.out.println(type2); if(type2 instanceof ParameterizedType)&#123; ParameterizedType type = (ParameterizedType) type2; Type[] typeArguments = type.getActualTypeArguments(); for(Type typeArgument : typeArguments)&#123; try &#123; Class typeArgClass = (Class) typeArgument; //抛出异常 System.out.println("typeArgClass = " + typeArgClass); &#125;catch(Exception ex) &#123; System.out.println("ExceptionInfo: "+ex.getMessage()); &#125; &#125; &#125; System.out.println("==================================="); Method method3 = MyClass.class.getMethod("testUnGeneric",null); Type type3 = method3.getReturnType(); //getReturnType()就可以返回类型 System.out.println(type3); //输出int &#125;&#125; 运行结果： Generic Method Parameter Types也可以通过反射得到方法中的泛型参数1234567public class MyClass &#123; protected List&lt;String&gt; stringList = ...; public void setStringList(List&lt;String&gt; list)&#123; this.stringList = list; &#125;&#125; 1method = Myclass.class.getMethod("setStringList", List.class); Type[] genericParameterTypes = method.getGenericParameterTypes();12345678910for(Type genericParameterType : genericParameterTypes)&#123; if(genericParameterType instanceof ParameterizedType)&#123; ParameterizedType aType = (ParameterizedType) genericParameterType; Type[] parameterArgTypes = aType.getActualTypeArguments(); for(Type parameterArgType : parameterArgTypes)&#123; Class parameterArgClass = (Class) parameterArgType; System.out.println("parameterArgClass = " + parameterArgClass); &#125; &#125;&#125; Generic Field Types123public class MyClass &#123; public List&lt;String&gt; stringList = ...;&#125; 123456789101112Field field = MyClass.class.getField("stringList");Type genericFieldType = field.getGenericType();if(genericFieldType instanceof ParameterizedType)&#123; ParameterizedType aType = (ParameterizedType) genericFieldType; Type[] fieldArgTypes = aType.getActualTypeArguments(); for(Type fieldArgType : fieldArgTypes)&#123; Class fieldArgClass = (Class) fieldArgType; System.out.println("fieldArgClass = " + fieldArgClass); &#125;&#125; Arraysjava.lang.reflect.Array使用java.lang.reflect.Array类处理数组的反射。 Creating Arrays1int[] intArray = (int[]) Array.newInstance(int.class, 3); 第一个参数为数组的类型，第二个参数为数组的大小。 Accessing Arrays通过Array.get()和Array.set()方法访问数组。123456789int[] intArray = (int[]) Array.newInstance(int.class, 3);Array.set(intArray, 0, 123);Array.set(intArray, 1, 456);Array.set(intArray, 2, 789);System.out.println("intArray[0] = " + Array.get(intArray, 0));System.out.println("intArray[1] = " + Array.get(intArray, 1));System.out.println("intArray[2] = " + Array.get(intArray, 2)); 上面的代码会打印：123intArray[0] = 123intArray[1] = 456intArray[2] = 789 Obtaining the Class Object of an Array获取数组的类对象 对于原始类型：1Class intArray = Class.forName("[I"); JVM使用I来表示int类型，[表示是一个int数组。其它primitive类型类似。 对于对象：1Class stringArrayClass = Class.forName("[Ljava.lang.String;"); [L表示是对象数组。 不能使用Class.forName()来获得原始类型的类对象，会抛出ClassNotFoundException异常。 12Class intClass1 = Class.forName("I");Class intClass2 = Class.forName("int"); 123456public Class getClass(String className)&#123; if("int" .equals(className)) return int .class; if("long".equals(className)) return long.class; ... return Class.forName(className);&#125; 12345//得到数组中元素的类型Class theClass = getClass(theClassName);//得到ltheClass构成的数组对象的类型Class stringArrayClass = Array.newInstance(theClass, 0).getClass(); 检查是否为数组类型：12Class stringArrayClass = Array.newInstance(String.class, 0).getClass();System.out.println("is array: " + stringArrayClass.isArray()); Obtaining the Component Type of an Array使用Class.getComponentType()获得数组中元素的类型：1234String[] strings = new String[3];Class stringArrayClass = strings.getClass();Class stringArrayComponentType = stringArrayClass.getComponentType();System.out.println(stringArrayComponentType); // will print java.lang.String Dynamic Proxies使用java.lang.reflect.Proxy可以在运行时创建接口的动态实现。 Creating Proxies使用Proxy.newProxyInstance()方法来创建动态代理，方法需要如下三个参数： 类加载器ClassLoader用来装载动态代理类。 要实现的接口对象数组。 InvocationHandler转发处理代理的方法。 12345InvocationHandler handler = new MyInvocationHandler();MyInterface proxy = (MyInterface) Proxy.newProxyInstance( MyInterface.class.getClassLoader(), new Class[] &#123; MyInterface.class &#125;, handler); InvocationHandler’s1234public interface InvocationHandler&#123; Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 1234567public class MyInvocationHandler implements InvocationHandler&#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //do something "dynamic" &#125;&#125; invoke()中的proxy对象为实现接口的动态代理对象。Method对象表示接口中方法的动态代理实现，可以使用反射得到方法名，参数列表以及返回类型。Object[] args数组表示方法的具体参数对象。 Known Use Cases动态代理的使用情形： Database Connection and Transaction Management Dynamic Mock Objects for Unit Testing Adaptation of DI Container to Custom Factory Interfaces AOP-like Method Interception Dynamic Class Loading and ReloadingThe ClassLoaderJava中类的加载由java.lang.ClassLoader的子类完成。当一个类被加载时，它所引用的所有类也被加载。这个类加载模式是递归的，直到所有需要的类都被加载。这可能不是应用程序中的所有类。未引用的类只有在引用时才加载。 The ClassLoader HierarchyJava中的类加载器被组织成一个层次结构。当您创建新的标准Java ClassLoader时，您必须提供一个父类ClassLoader。如果一个ClassLoader被要求加载一个类，它会要求它的父类加载器加载它。如果父类加载器找不到该类，那么子类加载器将尝试自己加载它。 Class Loading类加载器在加载类时的步骤如下： Check if the class was already loaded.（检查类是否已经被加载） If not loaded, ask parent class loader to load the class.（如果没有被加载，则请求父类加载器加载） If parent class loader cannot load class, attempt to load it in this class loader.（如果父加载器不能加载，则尝试自己加载类） Dynamic Class Loading1234567891011121314public class MainClass &#123; public static void main(String[] args)&#123; ClassLoader classLoader = MainClass.class.getClassLoader(); try &#123; Class aClass = classLoader.loadClass("MyClass"); System.out.println("aClass.getName() = " + aClass.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; Dynamic Class ReloadingJava的内置Class加载器在加载之前总是检查一个类是否已经被加载。因此，使用Java的内置类加载器不能重新加载类。重新加载一个类，你将不得不实现你自己的ClassLoader子类。每个加载的类都需要链接。这是使用ClassLoader.resolve（）方法完成的。这个方法是final的，因此不能在你的ClassLoader子类中重写。resolve（）方法将不允许任何给定的ClassLoader实例连接两次相同的类。因此，每次你想重新加载一个类，你都必须使用ClassLoader子类的一个新实例。这不是不可能的，但是在设计类重新加载时需要知道。 Designing your Code for Class Reloading如前所述，您不能使用已经加载该类的ClassLoader重载一个类。因此，您将不得不使用不同的ClassLoader实例重新加载类。加载到Java应用程序中的每个类都由其完全限定的名称（包名称+类名称）和加载它的ClassLoader实例标识。这意味着，类加载器A加载的类MyObject与载类加载器B的MyObject类不是同一个类。12MyObject object = (MyObject) myClassReloadingFactory.newInstance("MyObject"); 如果myClassReloadingFactory对象工厂使用与上面的代码所在的类不同的类加载器重新加载MyObject类，您不能将重新装入的MyObject类的实例转换为对象变量的MyObject类型。由于两个MyObject类用不同的类加载器加载，因此即使它们具有相同的完全限定类名，它们也被视为不同的类。试图将一个类的对象转换为另一个类的引用将导致ClassCastException。 使用如下方式解决： Use an interface as the variable type, and just reload the implementing class.（使用一个接口作为变量类型，并重新加载实现类。） Use a superclass as the variable type, and just reload a subclass.（使用超类作为变量类型，并重新加载一个子类。） 12MyObjectInterface object = (MyObjectInterface) myClassReloadingFactory.newInstance("MyObject"); 12MyObjectSuperclass object = (MyObjectSuperclass) myClassReloadingFactory.newInstance("MyObject"); 当你的类加载器被要求加载MyObject类时，它也会被要求加载MyObjectInterface类或者MyObjectSuperclass类，因为这些类是从MyObject类中引用的。您的类加载器必须将这些类的加载委托给加载包含接口或超类型变量的类的相同类加载器。 ClassLoader Load / Reload Example1234567891011121314151617181920212223242526272829303132333435363738394041public class MyClassLoader extends ClassLoader&#123; public MyClassLoader(ClassLoader parent) &#123; super(parent); &#125; public Class loadClass(String name) throws ClassNotFoundException &#123; if(!"reflection.MyObject".equals(name)) return super.loadClass(name); try &#123; String url = "file:C:/data/projects/tutorials/web/WEB-INF/" + "classes/reflection/MyObject.class"; URL myUrl = new URL(url); URLConnection connection = myUrl.openConnection(); InputStream input = connection.getInputStream(); ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int data = input.read(); while(data != -1)&#123; buffer.write(data); data = input.read(); &#125; input.close(); byte[] classData = buffer.toByteArray(); return defineClass("reflection.MyObject", classData, 0, classData.length); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 1234567891011121314151617181920212223public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; ClassLoader parentClassLoader = MyClassLoader.class.getClassLoader(); MyClassLoader classLoader = new MyClassLoader(parentClassLoader); Class myObjectClass = classLoader.loadClass("reflection.MyObject"); AnInterface2 object1 = (AnInterface2) myObjectClass.newInstance(); MyObjectSuperClass object2 = (MyObjectSuperClass) myObjectClass.newInstance(); //create new class loader so classes can be reloaded. classLoader = new MyClassLoader(parentClassLoader); myObjectClass = classLoader.loadClass("reflection.MyObject"); object1 = (AnInterface2) myObjectClass.newInstance(); object2 = (MyObjectSuperClass) myObjectClass.newInstance();&#125; 这是使用类加载器加载的reflection.MyObject类。注意它是如何扩展一个超类并实现一个接口的。1234public class MyObject extends MyObjectSuperClass implements AnInterface2&#123; //... body of class ... override superclass methods // or implement interface methods&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法说明]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2FMarkdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Markdown语法 &copy; 特殊字符自动转换在HTML中&lt; 和&amp;会转换为&amp;lt;和&amp;amp; 区块元素段落和换行一个MarkDown段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本组成」这句话其实暗示了Markdown允许段落内强迫换行（插入换行符），这个特性和其他大部分的text-to-HTML格式不一样（包括Movable Type的「Convert Line Breaks」选项），其他的格式会把每个换行符都转换成&lt;br/&gt;标签。 标题Markdown支持两种标题语法，类Setext和类atx形式。类Setext形式是用底线的形式，利用=（最高阶标题）和-（第二阶标题），例如：12345This is an H1==========This is an H2---------------- 任何数量的=和-都可以有效果。效果： This is an H1This is an H2类Atx形式则是在行首插入1到6个#，对应标题1到6阶，例如：123# 这是H1## 这是H2###### 这是H6 效果： 这是H1这是H2这是H6你可以选择性地「闭合」类atx样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你可以在行尾加上#，而行尾的#的数量也不用和开头一样（行首的#字符数量决定标题的阶数）：12# 这是H1 ### 这是H2 ## 区块引用 BlockquotesMarkdown标记区块引用是使用类似email中用&gt;的引用方式。如果你还熟悉在email信件中的引言部分，你就知道怎么在Markdown文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;：123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 效果： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown也允许你偷懒只在整个段落的第一行加上&gt;：123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 效果： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;：12345&gt; This is first level of quoting.&gt;&gt;&gt; This is nested blockquote.&gt;&gt; Back to the first level. 效果： This is the first level of quoting. This is nested blockquote. Back to the first level. 引用区块内也可以使用其他Markdown语法，包括标题、列表、代码区块等：12345678&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 效果： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $inout | $markdown_script”); 列表Markdown支持有序列表和无序列表无序列表使用星号、加号或是减号作为列表标记：123* Red* Green* Blue 效果： Red Green Blue 等同于：123+ Red+ Green+ Blue 效果: Red Green Blue 也等同于：123- Red- Green- Blue 效果： Red Green Blue 有序序号则使用数字接着一个英文句点：1231. Bird2. McHale3. Parish 效果： Bird McHale Parish 很重要的一点是，你在列表上使用的数字并不会影响输出的HTML结果，上面的列表所产生的HTML标记为：12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的列表标记写成：1231. Bird1. McHale1. Parish 或者是：1233. Bird1. McHale8. Parish 你都会得到完全相同的HTML输出。重点在于，你可以让Markdown文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从1.开始，因为Markdown未来可能会支持有序列表的start属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，做多3个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 效果： Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果项目列表间用空行分开，在输出HTML时Markdown就会将项目内容用&lt;p&gt;标签包起来，举例来说：12* Bird* Magic 会被转换为：1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个：123* Bird* Magic 会被转换为:1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符：123456781. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 效果： This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会好看很多，当然，再次地，如果你很懒惰，Mardown也允许：1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 效果： This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. 如果要在列表项目内放进引用，那&gt;就需要缩进：1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 效果： A list item with a blockquote: This is a blockquoteinside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是8个空格或是2个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 效果： 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生像下面这样的写法：11986. What a great season. 效果： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。11986\. What a great season. 效果： 1986. What a great season. 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown会用&lt;pre&gt;和&lt;code&gt;标签来把代码区块包起来。要在Markdown中建立代码区块很简单，只要简单地缩进4个空格或是一个制表符就可以，例如：123这是一个普通段落： 这是一个代码区块。 Markdown会转换成：1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 效果： 这是一个普通段落： 这是一个代码区块。这是一个普通段落： 这是一个代码区 这个每行一阶的缩进（4个空格或是1个制表符），都会被移除，例如：12345Here is an example of AppleScript: tell application "Foo" beep end tell 会被转换为：123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application "Foo" beepend tell&lt;/code&gt;&lt;/pre&gt; 效果： Here is an example of AppleScript: tell application “Foo” beepend tell一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面，&amp;、&lt;、和&gt;会自动转成HTML实体，这样的方式让你非常容易使用Markdown插入范例用的HTML原始码，之需要复制粘帖上，再加上缩进就可以了，剩下的Markdown都会帮你处理，例如：123&lt;div class="footer"&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为：1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 效果： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 代码区块中，一般的Markdown语法不会被转换，像是星号便只是星号，这表示你可以很容易地以Markdown语法撰写Markdown语法相关的文件。 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：123456* * *********---- - -_____________ 效果： 区段元素链接Markdown支持两种形式的链接语法：行内式和参考式两种形式。不管是哪一种，链接文字都是用[方括号]来标记。 要建立一个行内式的链接，只要在方括号后面紧接着圆括号并插入网址链接即可，如果你还想加上链接的title文字，只要在网址后面，用双引号把title文字包起来即可，例如：123This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. 会产生：12345&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 效果：This is an example inline link. This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径：1See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而第二个方括号里面要填入用以辨识链接的标记：1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格：1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：1[id]: http://example.com/ "Optional Title Here" 效果： This is an example reference-style link. This is an example reference-style link.链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的地址 选择性地接着title内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同：123[foo1]: http://example.com/ "Optional Title Here"[foo2]: http://example.com/ 'Optional Title Here'[foo3]: http://example.com/ (Optional Title Here) 效果： This is foo of first[foo2]: http://example.com/ ‘Optional Title Here’This is [foo of second][foo2] This is foo of third链接的网址也可以用尖括号包起来：1[id]: &lt;http：//example.com/&gt; "Optional Title Here" 你也可以把title属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：12[id]: http://example.com/longish/path/to/resource/here "Optional Title Here" 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：12[link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让“Google”链接到google.com,你可以简化成:1[Google][] 然后定义链接内容：1[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：1Visit [Daring Fireball][] for more information. 然后接着定义链接：1[Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。下面是一个参考式链接的范例：123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ "Google" [2]: http://search.yahoo.com/ "Yahoo Search" [3]: http://search.msn.com/ "MSN Search" 如果改成用链接名称的方式写：123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ "Google" [yahoo]: http://search.yahoo.com/ "Yahoo Search" [msn]: http://search.msn.com/ "MSN Search" 上面两种写法都会产生下面的 HTML。1234&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"title="Google"&gt;Google&lt;/a&gt; than from&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：123I get 10 times more traffic from [Google](http://google.com/ "Google")than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or[MSN](http://search.msn.com/ "MSN Search"). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调Markdown使用(*)和(_)作为标记强调字词的符号，被*或_包围的字词会被转成用&lt;em&gt;标签包围，用两个*或_包起来的话，则会被转成&lt;strong&gt;，例如：1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成：1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 效果： single asterisks single underscores double asterisks double underscores 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间：1un*frigging*believable unfriggingbelievable但是如果你的*和_两边都有空白的话，它们只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：1\*this text is surrounded by literal asterisks\* *this text is surrounded by literal asterisks* 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`)，例如：1Use the `printf()` function. 会产生：1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 效果：Use the printf() function.如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：1``There is a literal backtick (`) here.`` 这段语法会产生：1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 效果： There is a literal backtick (`) here. 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 会产生：123&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 效果： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：1Please don't use any `&lt;blink&gt;` tags. 转为：1&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 效果： Please don’t use any &lt;blink&gt; tags. 你也可以这样写：1`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生：12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 效果： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是：123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") 详细叙述如下： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’文字。 参考式的图片语法则长得像这样：1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：1[id]: url/to/image "Optional title attribute" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt;标签。 其它自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：1&lt;http://example.com/&gt; Markdown 会转为：1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 效果： http://www.baidu.com/ 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：1&lt;address@example.com&gt; Markdown 会转成：1234&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 效果：&#x61;&#100;&#x64;&#x72;&#x65;&#x73;&#x73;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠：1\*literal asterisks\* 效果： *literal asterisks* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 注释stackoverflow markdown注释单行12[//]: # "Comment"[//]: # (Comment)]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vagrant介绍与使用]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2Fvagrant-e4-bb-8b-e7-bb-8d-e4-b8-8e-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Vagrant是自动配置虚拟机的软件，定义好Vagrantfile配置文件 即可通过vagrant up启动一批虚拟机环境。在多人协作开发时可以通过配置来保证每个开发人员构建的机器环境一致参考官网vagrant]]></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux屏幕截图]]></title>
    <url>%2Fblog%2F2017%2F07%2F11%2Flinux-e5-b1-8f-e5-b9-95-e6-88-aa-e5-9b-be%2F</url>
    <content type="text"><![CDATA[使用命令截图 安装scrot后 scrot -s filename.png 鼠标选择窗口 对于KDE桌面可以使用spectcale]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FFT理解实现及应用]]></title>
    <url>%2Fblog%2F2016%2F05%2F08%2Ffft-e7-90-86-e8-a7-a3-e5-ae-9e-e7-8e-b0-e5-8f-8a-e5-ba-94-e7-94-a8%2F</url>
    <content type="text"><![CDATA[FFT的理解参考算法导论与FFT的简单理解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLYWEIGHT(享元)---对象结构型模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fflyweight-e4-ba-ab-e5-85-83-e5-af-b9-e8-b1-a1-e7-bb-93-e6-9e-84-e5-9e-8b-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>FLYWEIGHT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中克隆与拷贝构造函数]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fjava-e4-b8-ad-e5-85-8b-e9-9a-86-e4-b8-8e-e6-8b-b7-e8-b4-9d-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0%2F</url>
    <content type="text"><![CDATA[参考A Guide to Object Cloning in JavaWhich is better option: Cloning or Copy constructors? Cloning 含义当我们使用clone()方法时，JVM做如下两件事：1. 如果这个类只包含原始数据类型成员，则创建一个对象的拷贝，原始数据成员被依次拷贝，返回指向新对象的Reference2. 如果类还包括引用数据类型则只拷贝了它的引用，没有开辟新的空间。 Java中的Clonejava中的类要支持clone需要实现如下两条1. 实现Cloneable接口2. 重写clone()方法Java docs about clone() method are given below (formatted and extract). /* Creates and returns a copy of this object. The precise meaning of "copy" may depend on the class of the object. The general intent is that, for any object x, the expression: 1) x.clone() != x will be true 2) x.clone().getClass() == x.getClass() will be true, but these are not absolute requirements. 3) x.clone().equals(x) will be true, this is not an absolute requirement. */ protected native Object [More ...] clone() throws CloneNotSupportedException; 第一条保证克隆对象和原对象在内存的不同地方（内存地址不一样） 第二条建议克隆对象和原始对象有相同的类类型，但不强制 第三条建议克隆对象和原始对象使用equals比较是形同，但也不强制 例子： string也会被拷贝是因为String类是不可变的,对String类的任何改变,都是返回一个新的String类对象Our first class is Employee class with 3 attributes. Id, name and department. public class Employee implements Cloneable{ private int employeeId; private String employeeName; private Department department; public Employee(int employeeId, String employeeName, Department department) { this.employeeId = employeeId; this.employeeName = employeeName; this.department = department; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } public int getEmployeeId() { return employeeId; } public void setEmployeeId(int employeeId) { this.employeeId = employeeId; } public String getEmployeeName() { return employeeName; } public void setEmployeeName(String employeeName) { this.employeeName = employeeName; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } } class Department { private int id; private String name; public Department(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 测试类 public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); System.out.println(cloned.getEmployeeId()); System.out.println(original != cloned); System.out.println(original.getClass()== cloned.getClass()); System.out.println(original.equals(cloned)); } } 把String改为StringBuilder就不能实现拷贝 现在我们修改Department会发现 original数据也会被修改 public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); cloned.getDepartment().setName("Software Development"); System.out.println(original.getDepartment().getName()); } } Cloned object changes are visible in original also. This way cloned objects can make havoc in system if allowed to do so. Anybody can come and clone your application objects and do whatever he likes. 浅拷贝是Java中默认实现方式，上面例子实现的就是浅拷贝，因为我们在Employee类的克隆方法中没有克隆 Department. 深拷贝使在克隆对象上的改变不影响original 修改Employee的克隆方法 @Override public Object clone() throws CloneNotSupportedException { Employee cloned = (Employee)super.clone(); cloned.setDepartment((Department)cloned.getDepartment().clone()); return cloned; } 同时Department也要实现clone()方法 @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } 测试： public class TestCloning { public static void main(String[] args) throws CloneNotSupportedException { Department dept = new Department(1,"Human Resource"); Employee original = new Employee(1,"Admin",dept); //clone original Employee cloned = (Employee)original.clone(); cloned.getDepartment().setName("Software Development"); System.out.println(original.getDepartment().getName()); System.out.println(cloned.getDepartment().getName()); } } 这时改变cloned的状态 不改变original的状态 实现深拷贝需要满足如下规则1. No need to separately copy primitives.2. All the member classes in original class should support cloning and in clone method of original class in context should call super.clone() on all member classes.3. If any member class does not support cloning then in clone method, one must create a new instance of that member class and copy all its attributes one by one to new member class object. This new member class object will be set in cloned object. 使用拷贝构造函数 public class PointOne { private Integer x; private Integer y; public PointOne (PointOne point) { this.x = point.x; this.y = point.y; } } 通过拷贝构造函数可以得到状态一致的对象 详见参考链接一 通过序列化克隆只要对应的类是可序列化的可以通过序列化机制实现克隆，做法： 直接将对象序列化到输出流中，然后将其读回。这样产生的新对象是对现有对象的一个深拷贝。可用ByteArrayOutputStream将数据保存到字节数组中。 但是 它通常会比显示地构建新对象并复制或克隆数据域的克隆方法慢的多，并且并不是所有对象是可序列化的，最后使类可序列化是很困难的，并不是所有的类都可以指望得到它的权利。 class Employee extends SerialCloneable { private String name; private double salary; private Date hireDay; public Employee(String n,double s,int year,int month,int day) { name = n; salary = s; GregorianCalendar calendar = new GregorianCalendar(year,month-1,day); hireDay = calendar.getTime(); } public String getName() { return name; } public double getSalary() { return salary; } public Date getHireDay() { return hireDay; } public void raiseSalay(double byPercent) { double raise = salary*byPercent/100.0; salary += raise; } public String toString() { return getClass().getName()+ "[name="+name +",salary="+salary +",hireDay="+hireDay +"]"; } } class SerialCloneable implements Cloneable,Serializable { @Override public Object clone() { try{ //save the object to a byte array ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bout); out.writeObject(this); out.close(); //read a clone of the object from the byte array ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream in = new ObjectInputStream(bin); Object ret = in.readObject(); in.close(); return ret; }catch(Exception e) { e.printStackTrace(); return null; } } } public class SerialCloneTest { public static void main(String[] args) { Employee harry = new Employee("Harry Hacker",35000,1989,10,1); Employee harry2 = (Employee)harry.clone(); harry2.raiseSalay(10); System.out.println(harry); System.out.println(harry2); } } 使用Apache工具包(using Apache commons)Apache commons has also utility function for deep cloning. If you feel interested the follow their official docs. Below is sample usage of cloning facility using Apache commons: SomeObject cloned = org.apache.commons.lang.SerializationUtils.clone(someObject); Best practices When you don’t know whether you can call the clone() method of a particular class as you are not sure if it is implemented in that class, you can check with checking if the class is instance of “Cloneable” interface as below. if(obj1 instanceof Cloneable){ obj2 = obj1.clone(); } //Dont do this. Cloneabe dont have any methods obj2 = (Cloneable)obj1.clone(); No constructor is called on the object being cloned. As a result, it is your responsibility, to make sure all the members have been properly set. Also, if you are keeping track of number of objects in system by counting the invocation of constructors, you got a new additional place to increment the counter.]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Clone</tag>
        <tag>Copy constructors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prototype Pattern(原型模式)]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2Fprototype-pattern-e5-8e-9f-e5-9e-8b-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[参考Prototype Design PatternFactory模式与Prototype模式的异同 the prototype is the object containing clone method used to clone similar objects to it for reducing the number of classesa solution to these problemsHow does one reduce the number of classes that share similar behavoir and relationships SolutionDefine a class to replace all the classes that share similar behavior and relationships. Save instances,called prototypes,of this class. To create an instance of any of the classes replaced, simply clone the desired prototype and modify its attributes Liabilities(缺点) The subclasses of prototype must implement the clone() method. This requires deep-copying if the instances and original must be independent;otherwise, shallow-copying is sufficient Implementing clone() may be difficult or impossible if the class is final or there are circular references 循环引用 无法克隆 Example Prototype in Java Create a “contract” with clone() and getName() entries Design a “registry” that maintains a cache of prototypical objects Populate the registry with an initializePrototypes() function The registry has a findAndClone() “virtual constructor” that can transform a String into its correct object (it calls clone() which then calls “new”) All classes relate themselves to the clone() contract Client uses the findAndClone() virtual ctor instead of the “new” operator package Prototype; interface Prototype { Object clone(); String getName(); } //1.The clone() contract interface Command { void execute(); } class PrototypesModule { //2\. &quot;registry&quot; of prototypical objs private static Prototype[] prototypes = new Prototype[9]; private static int total = 0; // Adds a feature to the Prototype attribute of the PrototypesModule class //obj The feature to be added to the Prototype attribute public static void addPrototype(Prototype obj) { prototypes[total++] = obj; } public static Object findAndClone(String name) { //4\. The &quot;virtual ctor&quot; for(int i=0;i&amp;lt;total;i++) { if(prototypes[i].getName().equals(name)) return prototypes[i].clone(); } System.out.println(name + &quot;not found&quot;); return null; } } //5\. Sign-up for the clone() contract `&lt;/pre&gt; &lt;/pre&gt; &lt;pre&gt; class This implements Prototype,Command { public Object clone() { return new This(); } public String getName() { return &quot;This&quot;; } public void execute() { System.out.println(&quot;This:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt; class That implements Prototype,Command { public Object clone() { return new That(); } public String getName() { return &quot;That&quot;; } public void execute() { System.out.println(&quot;That:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt; class TheOther implements Prototype,Command { public Object clone() { return new TheOther(); } public String getName() { return &quot;TheOther&quot;; } public void execute() { System.out.println(&quot;TheOther:execute&quot;); } } &lt;/pre&gt; &lt;pre&gt;`public class PrototypeDemo { //3\. Populate the &quot;registry&quot; public static void initializePrototypes() { PrototypesModule.addPrototype(new This()); PrototypesModule.addPrototype(new That()); PrototypesModule.addPrototype(new TheOther()); } public static void main(String[] args) { initializePrototypes(); Object[] objects = new Object[9]; int total = 0; // 6\. Client does not use &quot;new&quot; for(int i=0;i&amp;lt;args.length;i++) { objects[total] = PrototypesModule.findAndClone(args[i]); if(objects[total]!=null) total++; } for(int i=0;i&amp;lt;total;i++) { ((Command)objects[i]).execute(); } } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Prototype Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singleton设计模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F19%2Fsingleton-e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[参考Efficetive Java page14深入浅出单实例Singleton设计模式如何正确地写出单例模式 Singleton 1.0版本 public class Singleton { private static Singleton instance =null; private Singleton() { System.out.println("Singleton 实例化"); } public static Singleton getInstance() { if(instance==null){ instance = new Singleton(); } return instance; } } Singleton的特点 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。 所形成的实例保存在自己类中的私有成员中。 我们取实例时，只需要使用Singleton.getInstance()就行了。 单线程下测试代码： public class Tests { public static void main(String[] args) { for(int i=1;i]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRASP通用职责分配软件模式]]></title>
    <url>%2Fblog%2F2016%2F04%2F18%2Fgrasp-e9-80-9a-e7-94-a8-e8-81-8c-e8-b4-a3-e5-88-86-e9-85-8d-e8-bd-af-e4-bb-b6-e6-a8-a1-e5-bc-8f%2F</url>
    <content type="text"><![CDATA[GRASP设计模式及OO设计原则 GRASP设计模式的全称是General Responsibility Assignment Software Patterns，即通用职责分配软件模式。它定义了9个基本的OO设计原则或基本的设计构件。这9个设计模式分别是： 控制器(Controller) 创建者(Creator) 高内聚(High cohesion) 间接性(Indirection) 信息专家(Information expert) 低耦合(Low coupling) 多态(Polymorphism) 预防变化(Protected variations) 纯虚构(Pure fabrication) 1.The Controller pattern the controller collaborates with the bussiness objects to handle the actor request the controller delivers the result to the presentation,which displays the result to the actor 为了解决如下问题(a solution to these problems)A. Decouple the presentation and bussiness objects B. Remove the responsibility to handle an actor request from the presentation and assign it to another object 缺点(liabilities)A controller may be assigned too many responsibilities,resulting in a so-called bloated controller 2.Creator the creator is the object that is responsible for creating an object of a class a solution to these problems,supposed that an object of class A is the creator of an object of class BA. Class A is an aggregation(聚合) of class BB. An object of class A contains objects of class BC. An object of class A records object of class BD. An object of class A closely uses objects of class BE. An object of class A has the information to create objects of class B 缺点(liabilities)One same object may have different creation behaviors 3 6 High cohesion Low coupling4 Indirection间接性模式关注这样一个问题：为了避免两个或多个事务之间直接耦合，应该如何分配职责？如何使对象解耦合，以支持低耦合并提高复用性潜力？ 间接性模式对此的回答是：将职责分配给中介对象，使其作为其他构件或服务之间的媒介，以避免它们之间的直接耦合。中介则实现了其他构件之间的间接性。 间接性模式的思想比较简单，即通过一个中介就能消除许多的耦合。在GoF的23种设计模式中，有许多模式都利用到了间接性的思想。比如桥接模式中，设计将抽象部分与其实现部分相分离，利用的就是在客户与实现之间增加了一个抽象层次。外观模式则是在整个子系统与客户之间增加了一个便于用户使用的外观类作为中介。而中介者模式中的中介者则更是典型的例子。 5 The expert pattern the expert is the object that is responsible for handling a request should have the information to fulfill the request a solution to these problemsA. who should be assigned the responsibility to handle a request B. Remove the excessive responsibility from the controller and assigning them to other objects 缺点(liabilities)The expert may become a big object 7 多态(Polymorphism)8 预防变化(Protected variations)防止变异模式关注这样一个问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？ 防止变异模式的回答是：识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定的接口。 防止变异（PV）是非常重要和基本的软件设计原则，几乎所有的软件或架构设计技巧都是防止变异的特例。PV是一个根本原则，它促成了大部分编程和设计的模式和机制，用来提供灵活性和防止变化。在软件设计中，除了数据封装、接口、多态、间接性等机制是PV的核心机制之外，没有一种固定的或者是通用的办法能够防止一切变化的产生。因此PV的实现依赖的是一系列的OO设计方面的经验性原则，用以产生一个设计良好的高内聚、低耦合的系统，从而支持PV。 这里需要参考文章面向对象设计原则 9 纯虚构(Pure fabrication)纯虚构模式关注这样一个问题：当你并不想违背高内聚和低耦合或其他目标，但是基于专家模式所提供的方案又不合适时，哪些对象应该承担这一职责？ OO设计中的领域模型是对领域内的概念内或现实世界中的对象的模型化表示。创建领域模型的关键思想是减小软件人员的思维与软件模式之间的表示差异。因此，在OO设计时，系统内的大多数类都是来源于现实世界中的真实类。然而，在给这些类分配职责时，有可能会遇到一些很难满足低耦合高内聚的设计原则。纯虚构模式对这一问题给出的方案是：给人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念，而代表虚构出来的事物，用以支持高内聚、低耦合和复用。 纯虚构模式强调的是职责应该置于何处。一般来说，纯虚构模式会通过表示解析或者行为解析来确定出一些纯虚构类，用于放置某一类职责。理想状况下，分配给这种虚构物的职责是要支持高内聚低耦合的，从而使整个系统处于一种良好的设计之中。 例如，在信息专家模式的最后一段所举的例子中提到，许多后台系统都需要对数据库进行操作，将系统中的一些对象进行持久化。信息专家模式给出的建议是将持久化的职责分配给具体的每一个模型类。但是这种建议已经被证明是不符合高内聚低耦合原则的，因为不会被采纳。于是，设计者往往会在系统中加入类似于DAO或者PersistentStorage这样的类。这些类在领域模型中是并不存在的，它们完全由设计者根据系统的行为而虚构得到。然而，这些类的引入，使得操作数据库进行持久化这种高内聚的职责可以顺理成章地分配给它们。从而在整个系统中实现了比较好的内聚和耦合。 在使用纯虚构模式时，不能毫无限制地对系统中的各种行为进行解析并纯虚构。如此往往会导致系统中大量的行为对象的存在，这样会对耦合产生不良的影响。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>GRASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP使用]]></title>
    <url>%2Fblog%2F2016%2F04%2F13%2Fjsp-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Jsp网页的组成模板数据静态部分，web容器不作处理，如HTML标签。 元素 脚本元素 指令元素 动作元素 Jsp 脚本元素类型脚本元素脚本语法 声明 &lt;%! 声明%&gt; 脚本 &lt;% 脚本%&gt; 脚本表达式 &lt;%= 脚本表达式%&gt; 说明：各个脚本类型的普通格式都有其对应的XML兼容格式，其区别在于：对普通格式页面的访问，会以HTML文件的形式显示，而访问对应的XML兼容格式时，会以XML文件的形式显示。 &lt;%!声明%&gt;声明语句用于声明方法和变量，对应的XML兼容格式为 &ltjsp:declaration&gt&lt/jsp:declaration&gt `&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HelloWorld&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;%! public long fact(long x){//声明 if(x == 0) return 1; else return x * fact(x - 1); } %&amp;gt; &amp;lt;table border=&quot;1&quot;&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;x&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;x!&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;% for(long i = 0; i &amp;lt; 20; i++){ %&amp;gt;&amp;lt;!--脚本--&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;%=i %&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;%=fact(i) %&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;%} %&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;` `&lt;/pre&gt; // 在声明中定义的变量是翻译成相应Java程序的成员变量, 在脚本中定义的变量是相应Java程序的局部变量。 * * * * * * &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; ## &lt;%脚本%&gt; &lt;/body&gt; &lt;/html&gt; 普通格式` 在&lt;%%&gt;标签里面写入Java代码，访问时以HTML文件的形式呈现。 '&lt;html&gt; &lt;head&gt;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String str = "HelloWorld"; out.println(str); %&gt; &lt;/body&gt; &lt;/html&gt;' 说明：脚本翻译成对应java程序的代码放在该java程序的_jspService()方法中，因此，在脚本中声明的变量是局部变量。 ` XML兼容格式 ` 在&lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt;标签间写入Java代码，访问时以XML文件的形式呈现。 示例： '&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" xmlns="http://www.w3.org/1999/xhtml" version="2.0"&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Simple jspx page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:scriptlet&gt; String str = "hello" ; out.println(str) ; &lt;/jsp:scriptlet&gt; &lt;/body&gt; &lt;/html&gt; &lt;/jsp:root&gt;' ` ## ` 脚本表达式用来显示动态生成的结果，对应的XML兼容格式为&lt;jsp:expression&gt;&lt;/jsp:expression&gt;。不能使用分号作为脚本表达式的结束符，脚本表达式可以是常量，也可以是动态计算出来的值。 示例： '&lt;html&gt; &lt;head&gt;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String str = "Hello World"; %&gt; &lt;%=str %&gt; &lt;/body&gt; &lt;/html&gt;' 说明：脚本表达式翻译成对应java程序的代码放在该java程序的_jspService()方法中的print()方法中。 ` ## JSP页面的注释 &lt;%–注释内容–%&gt;//jsp注释，注释内容不会翻译为java代码，浏览器和源码中无法看到。 //HTML注释，会翻译为对应的java代码，在浏览器中注释的内容不会显示，查看源代码看得到注释的内容。&lt;%//%&gt;、&lt;%/**/%&gt;//java注释，会翻译为java代码,但是不作为响应的内容，浏览器和源码中无法看到。例子&#39;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HelloWorld&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;% String str = &quot;aaa&quot;; %&amp;gt; &amp;lt;%--&amp;lt;%=str %&amp;gt; --%&amp;gt; //jsp注释 &amp;lt;!--&amp;lt;%=str %&amp;gt; --&amp;gt; //HTML注释，无法在浏览器中看到，但可在网页源文件中看到&amp;lt;!--aaa--&amp;gt; &amp;lt;% //String str2 = &quot;bbb&quot;; %&amp;gt; //java注释 &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&#39; # JSP指令元素 JSP指令元素&amp;lt;%@指令类型 属性名=”属性值”%&amp;gt;用于提供整个JSP页面的相关信息，用来设定JSP页面的相关属性。## Page指令page指令的功能是设定整个JSP页面的属性和相关功能，用于翻译阶段与web容器的通讯。语法：&#x25;&#x40;&#x70;&#x61;&#103;&#101;&#23646;&#24615;&#x540d;&#x3d;&#8221;&#23646;&#x6027;&#20540;&#x201d;&#x25;对应的xml兼容格式语法为：&lt;jsp:directive.page属性名=”属性值”/&gt;### Page指令的属性属性名描述默认值language脚本语言名称“java”info网页信息无contentTypeMIME类型及字符编码“text/html;charset=ISO-8859-1”import类和包nonebuffer缓冲区大小8192kautoFlush自动刷新truesession能否获取session对象trueisThreadSafe是否线程安全trueerrorPage指定错误页面noneisErrorPage允许为错误页面falseextends指定父类无例子&#39;&amp;lt;%@page contentType=&quot;text/html; charset=utf-8&quot; info=&quot;aa&quot; %&amp;gt; &amp;lt;!--翻译成的java代码为response.setContentType(“text/html;charset=utf-8”)--&amp;gt; &amp;lt;%@page import=&quot;java.util.Date&quot;%&amp;gt; &amp;lt;!--翻译成的java代码为import java.util.Date--&amp;gt; &amp;lt;%@page import=&quot;java.text.SimpleDateFormat&quot;%&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;pageTest&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;% Date date = new Date(); SimpleDateFormat sd = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); %&amp;gt; &amp;lt;h1&amp;gt;当前系统时间：&amp;lt;%=sd.format(date) %&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&#39;### include指令（静态包含）：include指令用于在JSP编译阶段插入一个包含文本或代码的文件，将文件中的文本静态地包含进当前JSP文件中，如：&lt;%@include file=”hello.jsp”%&gt;。静态包含的文本最好不要有HTML标签和body标签，因为被包含的文件的全部内容将被插入到JSP文件中include指令所在的地方，这些标签会同JSP文件中已有的同样的标签发生冲突，静态包含的文件名不能是变量名且不能传递参数。### taglib指令taglib指令能让用户在页面中使用自定义的标签。语法：&lt;%@taglib uri=”uri” prefix=”tagPrefix”%&gt;对应的xml兼容格式语法为：&lt;jsp:directive.taglib uri=”uri” prefix=”tagPrefix”/&gt;## JSP动作元素JSP动作利用XML语法格式的标记来控制Servlet引擎的行为。利用JSP动作可以动态地插入文件、重用JavaBean组件、重定向用户到另外的页面、为java插件生成HTML代码、实现页面与组件的通信。### &amp;lt;jsp:include/&amp;gt;动作(动态包含):语法: &amp;lt;jsp:include page=&quot;localUrl&quot; flush=&quot;true&quot;/&amp;gt;,flush为true表示缓冲区满时，自动刷新页面。### &amp;lt;jsp:forward/&amp;gt;动作（页面转发）：语法：&amp;lt;jsp:forward page=”url”/&amp;gt;，相当于RequestDispatcher的forward方法, 将请求转发出去。## 动态包含和静态包含的区别☆ 根本区别在于包含的时机，静态包含是在编译期间包含，而动态包含是在运行期间包含。☆ 静态包含的是代码，动态包含的只是响应的内容。☆ 静态包含适用于包含静态页面，动态包含适用于包含动态页面。☆ 静态包含不能传递参数，动态包含可以传递参数。① 、编写includeTest1.jsp如下： &amp;lt;body&amp;gt; &amp;lt;% int i=100; String str=&quot;includeTest1.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt;&amp;lt;br&amp;gt; &amp;lt;jsp:include page=&quot;includeTest2.jsp&quot;&amp;gt;&amp;lt;/jsp:include&amp;gt; &amp;lt;/body&amp;gt; 再编写includeTest2.jsp如下： &amp;lt;body&amp;gt; &amp;lt;% int i=600; String str=&quot;includeTest2.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt; &amp;lt;/body&amp;gt; 启动tomcat，在浏览器中输入http://localhost:8080/myapp/includeTest1.jsp查看结果如下： includeTest1.jsp中i值是：100 includeTest2.jsp中i值是：600 ② 、将includeTest1.jsp改为如下： &amp;lt;body&amp;gt; &amp;lt;% int i=100; String str=&quot;includeTest1.jsp&quot;; %&amp;gt; &amp;lt;%=str %&amp;gt;中i值是：&amp;lt;%=i %&amp;gt;&amp;lt;br&amp;gt; &amp;lt;%@ include file=&quot;includeTest2.jsp&quot;%&amp;gt; &amp;lt;/body&amp;gt; 将includeTest2.jsp改为如下： &amp;lt;body&amp;gt; &amp;lt;%=str%&amp;gt;中i值是：&amp;lt;%=i %&amp;gt; &amp;lt;/body&amp;gt; 在浏览器中输入：http://localhost:8080/myapp/includeTest1.jsp查看结果如下： includeTest1.jsp中i值是：100 includeTest1.jsp中i值是：100 ③ 、从上例可知，动态包含时，包含和被包含的文件互不影响，只是将被包含文件编译执行后的结果放入了包含的文件中；静态包含相当于将被包含的文件中的文本直接放入了包含的文件中，然后编译执行。## JSP隐式对象隐式对象就是不用实例化，可以直接在JSP页面中使用的对象，如下表所示： 对象 描述 request 代表与请求相关的HttpServletRequest对象 response 代表与响应相关的HttpServletResponse对象 PageContext 代表封装请求某个JSP页面时请求环境的PageContext对象 session 代表特定用户请求会话的HttpSession对象 application 代表web应用程序的ServletContext对象 out 代表与响应输出流相关的jspWriter对象 config 代表JSP页面的Servlet相关的ServletConfig对象 page 等于java中的this变量 exception JSP页面抛出的Throwable对象，这个对象只能在JSP错误页面中使用 ### out对象out对象是一个输出缓冲流，用来给客户端返回信息，它是javax.servlet.jsp.JspWriter的一个实例。out对象常用方法：☆println()：向客户端输出各种类型的数据☆newLine()：输出一个换行符☆close()：关闭输出流☆flush()：输出缓冲区里的数据☆clearBuffer()：清除缓冲区里的数据，同时把数据输出到客户端☆clear()：清除缓冲区里的数据，但不把数据输出到客户端☆getBufferSize()：返回缓冲区的大小### pageContext对象：pageContext对象可以获取其他隐式对象、可以实现页面的转发和包含、可以用它对四个作用域空间进行数据的存取，它是javax.servlet.jsp.PageContext的实例。① pageContext对象获取其他隐式对象：☆getRequest ：获得request隐式对象☆getResponse：获得response隐式对象☆getServletConfig：获得config隐式对象☆getServletContext：获得application隐式对象☆getPage：获得page隐式对象☆getSession：获得session隐式对象②pageContext对象对四个作用域空间进行数据的存取：pageContext对象提供了四个常量，用来表示四个作用域：☆PAGE_SCOPE：pageContext作用域，只在当前页面有效☆REQUEST_SCOPE： request作用域，在forward转发的页面有效☆SESSION_SCOPE：session作用域，IE浏览器未关闭就一直有效☆APPLICATION_SCOPE：application作用域，未重启Tomcat就一直有效。③pageContext对象实现页面的转发和包含：pageContext.forward(String relativeURL);//实现页面的转发pageContext.include(String relativeURL);//实现页面的包含例子`例1，获取web.xml配置文件中jsp的初始化参数：先在tomcat安装目录下的webapps目录中新建/myapp/WEB-INF/路径，并在WEB-INF目录中编写web.xml如下：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;web-app version=”2.5” xmlns=”http://java.sun.com/xml/ns/javaee“ xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance“ xsi:schemaLocation=”http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&amp;gt; &lt;servlet&gt; &lt;servlet-name&gt;param&lt;/servlet-name&gt; &lt;jsp-file&gt;/get.jsp&lt;/jsp-file&gt;&lt;!–指定jsp文件，路径相对于当前web项目文件夹–&gt; &lt;init-param&gt;&lt;!–JSP的初始化参数–&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhangsan&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;param&lt;/servlet-name&gt; &lt;url-pattern&gt;/get.jsp&lt;/url-pattern&gt;!--http://localhost:8080/myapp/get.jsp对应该jsp-- &lt;/servlet-mapping&gt;&lt;/web-app&gt;然后在myapp目录中编写get.jsp如下：&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;%&gt;&lt;html&gt; &lt;head&gt; &amp;lt;base href=&quot;&amp;lt;%=basePath%&amp;gt;&quot;&amp;gt; &amp;lt;!--base标签设置当前页面的根路径，即当前页面的其他路径可以相对base标签设置的路径而设置--&amp;gt; &amp;lt;title&amp;gt;My JSP &apos;forward.jsp&apos; starting page&amp;lt;/title&amp;gt; &lt;%! public void jspInit() {//访问该jsp时执行该方法 System.out.println(&quot;初始化&quot;); }public void jspDestroy() {//该jsp对应的Java程序(servlet)销毁时执行 System.out.println(&quot;销毁&quot;); }%&gt; &lt;/head&gt;&lt;body&gt;&lt;% String param = config.getInitParameter(&quot;name&quot;); //获取web.xml中jsp的初始化参数 out.println(&quot;param-value in web.xml is :&quot;+param); %&gt;&lt;br/&gt; basePath is &amp;lt;%=basePath%&amp;gt; &lt;/body&gt;&lt;/html&gt;最后启动tomcat，在浏览器中输入：http://localhost:8080/myapp/get.jsp访问。` `例2，在request作用域中传递绑定的对象：先在tomcat安装目录下的webapps目录中新建myapp目录，然后在myapp目录中编写sendEmp.jsp如下：&lt;html&gt;&lt;body&gt;&lt;%request.setAttribute(“emp”,”scott”);%&gt; &amp;lt;jsp:forward page=&quot;getEmp.jsp&quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;&amp;lt;!--请求转发--&amp;gt; &lt;/body&gt;&lt;/html&gt;继续在myapp目录中编写getEmp.jsp如下：&lt;%String emp = (String)pageContext.getAttribute(“emp”,PageContext.REQUEST_SCOPE);String emp2 = (String)request.getAttribute(“emp”);//这句和上句意思一样out.println(emp+” “+emp2);%&gt;启动tomcat，在浏览器中输入：http://localhost:8080/myapp/sendEmp.jsp访问。 ##另外]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2Fblog%2F2016%2F04%2F13%2Fe9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e8-ae-be-e8-ae-a1-e5-8e-9f-e5-88-99%2F</url>
    <content type="text"><![CDATA[一些软件设计的原则面向对象设计原则和创建SOLID应用的5个方法 迪米特法则定义： 一个对象应该对其它对象保持最少的了解 从而降低类之间的耦合 具体来说对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法： 对象O 与O直接相关的Component Object 由方法M创建或者实例化的对象 作为方法M的参数的对象例子：demeter SOLID 原则单一职责 （SRP)一个类发生变化的原因不应该超过一个。这意味着代码中每个类，或者类似的结构只有一个功能。 里氏替换原则 （LSP)子类必须能够替换成它们的基类。即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。A. Derived types must be completely substitutable for their base typesB. This principle is just an extension of the Open Close PrincipleC. Making sure that new derived classes are extending the base classes withoutchanging their behavior 正方形不是矩形的例子 接口隔离原则 （ISP)接口隔离原则(Interface Segregation Principle)指出客户不应该被强迫依赖于他们不使用的接口。当我们使用非内聚的接口时，ISP指导我们创建多个较小的内聚度高的接口。 当你应用ISP时，类和他们的依赖使用紧密集中的接口通信，最大限度地减少了对未使用成员的依赖，并相应地降低耦合度。小接口更容易实现，提升了灵活性和重用的可能性。由于很少的类共享这些接口，为响应接口的变化而需要变化的类数量降低，增加了鲁棒性。 A. Clients should not be forced to depend upon interfaces that they don’t use 依赖反转原则 （DIP)依赖反转原则(Dependency Inversion Principle,DIP)指出高层次模块不应该依赖于低层次模块；他们应该依赖于抽象。第二，抽象不应该依赖于细节；细节依赖于抽象。方法是将类孤立在依赖于抽象形成的边界后面。如果在那些抽象后面所有的细节发生变化，那我们的类仍然安全。这有助于保持低耦合，使设计更容易改变。A. High-level modules should not depend on low-level modules. Both shoulddepend on abstractionsB. Abstractions should not depend on details. Details should depend onabstractions 开闭原则（OCP)关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 A. Software entities like classes, modules and functions should be open forextensionbut closedformodificationsB. The design and writing of the code should be done in a way that newnctionality should be added with minimum changes in the existing codeC. The design should be done in a way to allow the adding of new functionality asnew classes, keeping as much as possible existing code unchanged 其它原则参考第一个链接一些软件设计的原则 Common Closure Principle（CCP）– 共同封闭原则 Common Reuse Principle (CRP) – 共同重用原则 Hollywood Principle – 好莱坞原则 High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 Convention over Configuration（CoC）– 惯例优于配置原则 Separation of Concerns (SoC) – 关注点分离 Design by Contract (DbC) – 契约式设计 Acyclic Dependencies Principle (ADP) – 无环依赖原则 Don’t Repeat Yourself (DRY) Keep It Simple, Stupid (KISS) Program to an interface, not an implementation Command-Query Separation (CQS) – 命令-查询分离原则 You Ain’t Gonna Need It (YAGNI)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用]]></title>
    <url>%2Fblog%2F2016%2F04%2F11%2Fmarkdown-e4-bd-bf-e7-94-a8%2F</url>
    <content type="text"><![CDATA[Markdown语法说明Markdown入门 Test这是一个html书写的表格 标题1标题2data1data2 Sum $180 &copy; This is an H1This is an H2这是H1这是H2这是H3这是H6 这是一段区块引用 This is the first level of quoting. This is nested blockquote. Back to the first level. 这是一个标题 这是第一行列表项 这是第二行列表项 给出一些例子代码：return shell_exec(“echo $input | $markdown_script”); markdown 支持有序列表和无序列表无序列表使用星号 加号或减号作为列表标记 Red Green Blue Red Green Blue Red Green Blue 有序列表使用数字接着一个英文句点 Bird McHale Parish Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is paragraph oneThis is paragraph one……. This is paragraph two 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 分割 分割 分割 This is an example inline link. 插入图片 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。这里是粗体 这里是斜体 代码‘Class Main{}’]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2Fblog%2F2016%2F04%2F11%2Fgit-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c%2F</url>
    <content type="text"><![CDATA[图解Git参考廖雪峰的Git教程Git分支管理初始化一个Git仓库，使用git init命令 添加文件到仓库： 1 使用git add 可反复添加多个文件 2 使用git commit -m “information” git status查看仓库状态 git diff filename 查看文件改动地方 git log查看历史纪录 git log –pretty=oneline 在Git中，用HEAD表示当前版本，也就是最新的提交 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 使用git reset –hard HEAD^回退到上个版本 其后也可以加版本号回退 Git提供了一个命令git reflog用来记录你的每一次命令 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 当使用git add filename 之后再回退可以使用 git reset HEAD filenamegit commit 之后需要版本回退 git reset –hard HEAD^ 或git reset –hard commit_id 删除文件： 用命令git rm删掉，并且git commit 用git checkout – filename 从版本库中还原到工作区远程仓库：]]></content>
      <categories>
        <category>工具软件学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆]]></title>
    <url>%2Fblog%2F2015%2F10%2F17%2Fe8-ae-b0-e5-bf-86%2F</url>
    <content type="text"><![CDATA[只如初见]]></content>
      <categories>
        <category>只如初见</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[世界，你好！]]></title>
    <url>%2Fblog%2F2015%2F10%2F17%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！]]></content>
      <categories>
        <category>问题笔记</category>
      </categories>
  </entry>
</search>
